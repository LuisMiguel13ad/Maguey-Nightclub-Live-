---
phase: 04-vip-system-reliability
plan: 04
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - maguey-pass-lounge/supabase/functions/cancel-event-with-refunds/index.ts
  - maguey-pass-lounge/supabase/migrations/20260130200000_cancel_event_rpc.sql
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Owner can cancel entire event with one action"
    - "All VIP reservations for event are refunded via Stripe"
    - "All VIP reservations status changed to cancelled"
    - "Floor plan tables reset to available after cancellation"
    - "GA tickets for event are also refunded (if applicable)"
  artifacts:
    - path: "maguey-pass-lounge/supabase/functions/cancel-event-with-refunds/index.ts"
      provides: "Edge function for event cancellation with refunds"
      contains: "stripe.refunds.create"
    - path: "maguey-pass-lounge/supabase/migrations/20260130200000_cancel_event_rpc.sql"
      provides: "RPC to get refundable reservations"
      exports: ["get_event_refundable_reservations"]
  key_links:
    - from: "cancel-event-with-refunds edge function"
      to: "stripe.refunds.create"
      via: "Stripe SDK call"
      pattern: "stripe\\.refunds\\.create"
    - from: "cancel-event-with-refunds edge function"
      to: "vip_reservations UPDATE"
      via: "Supabase client update"
      pattern: "update.*status.*cancelled"
---

<objective>
Implement owner-initiated event cancellation with automatic bulk refunds for all VIP reservations.

Purpose: Per 04-CONTEXT.md, when owner cancels an event, all VIP reservations should be fully refunded via Stripe. This is a critical business requirement for handling event cancellations gracefully.

Output: Edge function that cancels an event, refunds all reservations, and resets table availability.
</objective>

<execution_context>
@/Users/luismiguel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luismiguel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-vip-system-reliability/04-CONTEXT.md
@.planning/phases/04-vip-system-reliability/04-RESEARCH.md
@maguey-pass-lounge/supabase/functions/stripe-webhook/index.ts
@maguey-pass-lounge/supabase/migrations/20260130000000_vip_state_transition_enforcement.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create database helper function for refundable reservations</name>
  <files>maguey-pass-lounge/supabase/migrations/20260130200000_cancel_event_rpc.sql</files>
  <action>
Create a migration with RPC function to get all refundable reservations for an event.

**Function: get_event_refundable_reservations**
```sql
CREATE OR REPLACE FUNCTION get_event_refundable_reservations(p_event_id VARCHAR)
RETURNS TABLE (
  reservation_id UUID,
  stripe_payment_intent_id VARCHAR,
  amount_paid_cents INTEGER,
  purchaser_email VARCHAR,
  purchaser_name VARCHAR,
  table_name VARCHAR,
  status VARCHAR
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  SELECT
    r.id as reservation_id,
    r.stripe_payment_intent_id,
    r.amount_paid_cents,
    r.purchaser_email,
    r.purchaser_name,
    t.table_name,
    r.status::VARCHAR
  FROM vip_reservations r
  LEFT JOIN event_vip_tables t ON t.id = r.event_vip_table_id
  WHERE r.event_id = p_event_id
    AND r.status IN ('confirmed', 'checked_in')
    AND r.stripe_payment_intent_id IS NOT NULL;
END;
$$;

GRANT EXECUTE ON FUNCTION get_event_refundable_reservations TO service_role;
```

**Also add function to check if event can be cancelled:**
```sql
CREATE OR REPLACE FUNCTION can_cancel_event(p_event_id VARCHAR)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_event RECORD;
  v_reservation_count INTEGER;
  v_total_refund_cents INTEGER;
BEGIN
  -- Get event details
  SELECT * INTO v_event FROM events WHERE id = p_event_id;

  IF NOT FOUND THEN
    RETURN json_build_object('can_cancel', FALSE, 'reason', 'Event not found');
  END IF;

  -- Check if event has started
  IF (v_event.event_date || ' ' || COALESCE(v_event.event_time, '00:00'))::timestamp < NOW() THEN
    RETURN json_build_object('can_cancel', FALSE, 'reason', 'Event has already started');
  END IF;

  -- Get refundable reservation count and total
  SELECT COUNT(*), COALESCE(SUM(amount_paid_cents), 0)
  INTO v_reservation_count, v_total_refund_cents
  FROM vip_reservations
  WHERE event_id = p_event_id
    AND status IN ('confirmed', 'checked_in')
    AND stripe_payment_intent_id IS NOT NULL;

  RETURN json_build_object(
    'can_cancel', TRUE,
    'reservation_count', v_reservation_count,
    'total_refund_cents', v_total_refund_cents,
    'event_name', v_event.name,
    'event_date', v_event.event_date
  );
END;
$$;

GRANT EXECUTE ON FUNCTION can_cancel_event TO service_role;
```
  </action>
  <verify>
```bash
cd maguey-pass-lounge && npx supabase db push --local

# Verify functions exist
npx supabase db execute --local "SELECT proname FROM pg_proc WHERE proname IN ('get_event_refundable_reservations', 'can_cancel_event');"
```
  </verify>
  <done>
RPC functions get_event_refundable_reservations and can_cancel_event exist in database.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create cancel-event-with-refunds edge function</name>
  <files>maguey-pass-lounge/supabase/functions/cancel-event-with-refunds/index.ts</files>
  <action>
Create a new edge function for event cancellation with bulk refunds.

**File structure:**
```
supabase/functions/cancel-event-with-refunds/
  index.ts
```

**Implementation:**
```typescript
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.39.3";
import Stripe from "https://esm.sh/stripe@14.14.0";

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
};

interface CancelEventRequest {
  event_id: string;
  cancelled_by: string;
  reason?: string;
}

interface RefundResult {
  reservation_id: string;
  purchaser_email: string;
  amount_cents: number;
  status: 'refunded' | 'failed';
  error?: string;
  refund_id?: string;
}

serve(async (req) => {
  // Handle CORS
  if (req.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const stripe = new Stripe(Deno.env.get("STRIPE_SECRET_KEY")!, {
      apiVersion: "2023-10-16",
    });

    const supabaseUrl = Deno.env.get("SUPABASE_URL")!;
    const supabaseServiceKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;
    const supabase = createClient(supabaseUrl, supabaseServiceKey);

    const { event_id, cancelled_by, reason }: CancelEventRequest = await req.json();

    if (!event_id) {
      return new Response(
        JSON.stringify({ success: false, error: "event_id is required" }),
        { status: 400, headers: { ...corsHeaders, "Content-Type": "application/json" } }
      );
    }

    // Check if event can be cancelled
    const { data: canCancelResult, error: canCancelError } = await supabase.rpc(
      'can_cancel_event',
      { p_event_id: event_id }
    );

    if (canCancelError || !canCancelResult.can_cancel) {
      return new Response(
        JSON.stringify({
          success: false,
          error: canCancelResult?.reason || canCancelError?.message || "Cannot cancel event"
        }),
        { status: 400, headers: { ...corsHeaders, "Content-Type": "application/json" } }
      );
    }

    // Get all refundable reservations
    const { data: reservations, error: fetchError } = await supabase.rpc(
      'get_event_refundable_reservations',
      { p_event_id: event_id }
    );

    if (fetchError) {
      console.error('Error fetching reservations:', fetchError);
      return new Response(
        JSON.stringify({ success: false, error: "Failed to fetch reservations" }),
        { status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" } }
      );
    }

    const results: RefundResult[] = [];
    let totalRefunded = 0;
    let failedCount = 0;

    // Process each reservation
    for (const reservation of reservations || []) {
      try {
        // Create Stripe refund
        const refund = await stripe.refunds.create({
          payment_intent: reservation.stripe_payment_intent_id,
          reason: 'requested_by_customer', // Event cancellation
        });

        // Update reservation status to cancelled
        await supabase
          .from('vip_reservations')
          .update({
            status: 'cancelled',
            cancellation_reason: reason || 'event_cancelled',
            refund_id: refund.id,
            refunded_at: new Date().toISOString(),
            updated_at: new Date().toISOString(),
          })
          .eq('id', reservation.reservation_id);

        results.push({
          reservation_id: reservation.reservation_id,
          purchaser_email: reservation.purchaser_email,
          amount_cents: reservation.amount_paid_cents,
          status: 'refunded',
          refund_id: refund.id,
        });

        totalRefunded += reservation.amount_paid_cents;
      } catch (refundError) {
        console.error(`Refund failed for ${reservation.reservation_id}:`, refundError);

        results.push({
          reservation_id: reservation.reservation_id,
          purchaser_email: reservation.purchaser_email,
          amount_cents: reservation.amount_paid_cents,
          status: 'failed',
          error: refundError instanceof Error ? refundError.message : 'Refund failed',
        });

        failedCount++;
      }
    }

    // Reset table availability for this event
    await supabase
      .from('event_vip_tables')
      .update({ is_available: true, updated_at: new Date().toISOString() })
      .eq('event_id', event_id);

    // Update event status if there's a status field
    await supabase
      .from('events')
      .update({
        status: 'cancelled',
        cancelled_at: new Date().toISOString(),
        cancelled_by: cancelled_by,
        cancellation_reason: reason,
        updated_at: new Date().toISOString(),
      })
      .eq('id', event_id);

    return new Response(
      JSON.stringify({
        success: true,
        event_id,
        reservations_processed: results.length,
        refunds_successful: results.length - failedCount,
        refunds_failed: failedCount,
        total_refunded_cents: totalRefunded,
        total_refunded_dollars: totalRefunded / 100,
        results,
      }),
      { headers: { ...corsHeaders, "Content-Type": "application/json" } }
    );

  } catch (error) {
    console.error('Event cancellation error:', error);
    return new Response(
      JSON.stringify({
        success: false,
        error: error instanceof Error ? error.message : "Internal server error"
      }),
      { status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" } }
    );
  }
});
```

**Note:** The state transition trigger from 04-01 must allow confirmed -> cancelled transition. This is why this plan depends on 04-01.
  </action>
  <verify>
```bash
# Check edge function syntax
cd maguey-pass-lounge && deno check supabase/functions/cancel-event-with-refunds/index.ts 2>/dev/null || echo "Deno check skipped (install deno for full validation)"

# Verify file exists
ls -la supabase/functions/cancel-event-with-refunds/index.ts
```
  </verify>
  <done>
Edge function cancel-event-with-refunds exists with Stripe refund logic, reservation status updates, and table availability reset.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add refund tracking columns to vip_reservations</name>
  <files>maguey-pass-lounge/supabase/migrations/20260130200000_cancel_event_rpc.sql</files>
  <action>
Extend the migration to add refund tracking columns to vip_reservations table.

**Add columns:**
```sql
ALTER TABLE vip_reservations
ADD COLUMN IF NOT EXISTS refund_id VARCHAR(255),
ADD COLUMN IF NOT EXISTS refunded_at TIMESTAMP WITH TIME ZONE,
ADD COLUMN IF NOT EXISTS cancellation_reason VARCHAR(255),
ADD COLUMN IF NOT EXISTS cancelled_by VARCHAR(255);
```

**Add columns to events table for cancellation tracking:**
```sql
ALTER TABLE events
ADD COLUMN IF NOT EXISTS cancelled_at TIMESTAMP WITH TIME ZONE,
ADD COLUMN IF NOT EXISTS cancelled_by VARCHAR(255),
ADD COLUMN IF NOT EXISTS cancellation_reason VARCHAR(255);
```

**Add index for cancelled reservations:**
```sql
CREATE INDEX IF NOT EXISTS idx_vip_reservations_refund_id
ON vip_reservations(refund_id)
WHERE refund_id IS NOT NULL;
```
  </action>
  <verify>
```bash
cd maguey-pass-lounge && npx supabase db push --local

# Verify columns exist
npx supabase db execute --local "SELECT column_name FROM information_schema.columns WHERE table_name = 'vip_reservations' AND column_name IN ('refund_id', 'refunded_at', 'cancellation_reason');"
```
  </verify>
  <done>
Refund tracking columns added to vip_reservations and events tables.
  </done>
</task>

</tasks>

<verification>
1. Migration applies without errors
2. RPC functions exist in database
3. Edge function file exists and passes syntax check
4. Refund tracking columns exist on vip_reservations
5. can_cancel_event returns correct pre-cancellation info
6. get_event_refundable_reservations returns reservations with payment intents
</verification>

<success_criteria>
- Edge function can be deployed to Supabase
- Calling function with valid event_id processes all reservations
- Each reservation gets Stripe refund created
- Each reservation status updated to 'cancelled'
- Event tables reset to available
- Function returns detailed results with refund counts and totals
</success_criteria>

<output>
After completion, create `.planning/phases/04-vip-system-reliability/04-04-SUMMARY.md`
</output>
