---
phase: 07-ux-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - maguey-pass-lounge/src/components/ui/loading-button.tsx
  - maguey-pass-lounge/src/components/ui/skeleton-card.tsx
  - maguey-pass-lounge/src/hooks/use-loading-state.ts
  - maguey-gate-scanner/src/components/ui/loading-button.tsx
  - maguey-gate-scanner/src/components/ui/skeleton-card.tsx
  - maguey-gate-scanner/src/hooks/use-loading-state.ts
autonomous: true

must_haves:
  truths:
    - "Buttons show spinner and disabled state during async operations"
    - "Content areas show skeleton placeholders while loading"
    - "Loading state prevents duplicate submissions"
  artifacts:
    - path: "maguey-pass-lounge/src/components/ui/loading-button.tsx"
      provides: "Button with integrated loading state"
      exports: ["LoadingButton"]
    - path: "maguey-pass-lounge/src/components/ui/skeleton-card.tsx"
      provides: "Composite skeleton patterns"
      exports: ["EventCardSkeleton", "TicketCardSkeleton", "TableCardSkeleton"]
    - path: "maguey-pass-lounge/src/hooks/use-loading-state.ts"
      provides: "Centralized loading state management"
      exports: ["useLoadingState"]
  key_links:
    - from: "loading-button.tsx"
      to: "@/components/ui/button"
      via: "extends Button component"
      pattern: "import.*Button.*from.*@/components/ui/button"
    - from: "skeleton-card.tsx"
      to: "@/components/ui/skeleton"
      via: "uses Skeleton primitive"
      pattern: "import.*Skeleton.*from.*@/components/ui/skeleton"
---

<objective>
Create shared loading state UI components for skeleton screens and loading buttons across all apps.

Purpose: Provides consistent loading feedback that matches the existing theme and prevents double-submissions. Skeletons match content dimensions to prevent layout shift.

Output: LoadingButton, skeleton card composites, and useLoadingState hook in both maguey-pass-lounge and maguey-gate-scanner apps.
</objective>

<execution_context>
@/Users/luismiguel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luismiguel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-ux-polish/07-CONTEXT.md
@.planning/phases/07-ux-polish/07-RESEARCH.md
@maguey-pass-lounge/src/components/ui/button.tsx
@maguey-pass-lounge/src/components/ui/skeleton.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create LoadingButton component</name>
  <files>
    maguey-pass-lounge/src/components/ui/loading-button.tsx
    maguey-gate-scanner/src/components/ui/loading-button.tsx
  </files>
  <action>
Create a LoadingButton component that wraps the existing Button with loading state support.

Implementation:
- Accept all Button props plus `isLoading: boolean` and optional `loadingText: string`
- When isLoading is true:
  - Show Loader2 icon with `animate-spin` class
  - Display loadingText (default "Processing...")
  - Set disabled state to true
- Use `min-w-[120px]` to prevent button size change during loading (per pitfall #5)
- Import Loader2 from lucide-react

Example API:
```tsx
<LoadingButton isLoading={isPaying} loadingText="Paying...">
  Complete Purchase
</LoadingButton>
```

Create identical components in both apps. They share the same implementation pattern but are independent files (no shared package).
  </action>
  <verify>
Files exist and export LoadingButton:
- `ls maguey-pass-lounge/src/components/ui/loading-button.tsx`
- `ls maguey-gate-scanner/src/components/ui/loading-button.tsx`
- Both files import Button and Loader2
  </verify>
  <done>LoadingButton component exists in both apps with isLoading prop, spinner icon, and min-width to prevent size changes.</done>
</task>

<task type="auto">
  <name>Task 2: Create skeleton card composites</name>
  <files>
    maguey-pass-lounge/src/components/ui/skeleton-card.tsx
    maguey-gate-scanner/src/components/ui/skeleton-card.tsx
  </files>
  <action>
Create composite skeleton components that match the exact dimensions of loaded content.

Components to create:

1. **EventCardSkeleton** - For event listing cards
   - Image placeholder: `h-48 w-full rounded-none` (matches EventCard)
   - Title: `h-6 w-3/4`
   - Date badge: `h-4 w-24`
   - Description: Two lines `h-4 w-full` and `h-4 w-2/3`
   - Use Card wrapper with CardHeader/CardContent

2. **TicketCardSkeleton** - For ticket type selection
   - Title: `h-5 w-1/2`
   - Price: `h-6 w-20`
   - Description: `h-4 w-full`
   - Button area: `h-10 w-full`

3. **TableCardSkeleton** - For VIP table cards
   - Table number: `h-8 w-16`
   - Capacity: `h-4 w-24`
   - Price: `h-6 w-28`
   - Status badge: `h-6 w-20`

All skeletons use existing Skeleton component with `animate-pulse` (already styled with bg-muted).

Create in both apps with same implementation.
  </action>
  <verify>
Files exist with correct exports:
- `grep -l "EventCardSkeleton" maguey-pass-lounge/src/components/ui/skeleton-card.tsx`
- `grep -l "TicketCardSkeleton" maguey-pass-lounge/src/components/ui/skeleton-card.tsx`
- `grep -l "TableCardSkeleton" maguey-pass-lounge/src/components/ui/skeleton-card.tsx`
  </verify>
  <done>Skeleton composites exist for EventCard, TicketCard, and TableCard patterns in both apps with dimensions matching actual content.</done>
</task>

<task type="auto">
  <name>Task 3: Create useLoadingState hook</name>
  <files>
    maguey-pass-lounge/src/hooks/use-loading-state.ts
    maguey-gate-scanner/src/hooks/use-loading-state.ts
  </files>
  <action>
Create a centralized loading state management hook that supports multiple named loading states.

Implementation:
```typescript
type LoadingKey = string;

interface UseLoadingStateReturn {
  isLoading: (key: LoadingKey) => boolean;
  startLoading: (key: LoadingKey) => void;
  stopLoading: (key: LoadingKey) => void;
  withLoading: <T>(key: LoadingKey, fn: () => Promise<T>) => Promise<T>;
}

export function useLoadingState(): UseLoadingStateReturn {
  const [loadingStates, setLoadingStates] = useState<Set<LoadingKey>>(new Set());

  const isLoading = useCallback((key: LoadingKey) =>
    loadingStates.has(key), [loadingStates]);

  const startLoading = useCallback((key: LoadingKey) => {
    setLoadingStates(prev => new Set(prev).add(key));
  }, []);

  const stopLoading = useCallback((key: LoadingKey) => {
    setLoadingStates(prev => {
      const next = new Set(prev);
      next.delete(key);
      return next;
    });
  }, []);

  const withLoading = useCallback(async <T>(key: LoadingKey, fn: () => Promise<T>): Promise<T> => {
    startLoading(key);
    try {
      return await fn();
    } finally {
      stopLoading(key);
    }
  }, [startLoading, stopLoading]);

  return { isLoading, startLoading, stopLoading, withLoading };
}
```

This allows components to track multiple loading states:
- `isLoading('payment')` - Check if payment in progress
- `withLoading('fetchEvents', fetchEvents)` - Auto-manage loading state for async function
  </action>
  <verify>
Hook exists and exports correctly:
- `grep -l "useLoadingState" maguey-pass-lounge/src/hooks/use-loading-state.ts`
- `grep "withLoading" maguey-pass-lounge/src/hooks/use-loading-state.ts`
  </verify>
  <done>useLoadingState hook exists in both apps with isLoading, startLoading, stopLoading, and withLoading utilities.</done>
</task>

</tasks>

<verification>
After completing all tasks:
1. All 6 files exist in their respective directories
2. No TypeScript errors: `cd maguey-pass-lounge && npx tsc --noEmit` (check for errors in new files)
3. Components follow existing conventions (named exports, cn utility usage)
</verification>

<success_criteria>
- LoadingButton shows spinner and disables during loading state
- Skeleton composites match content dimensions (no layout shift)
- useLoadingState supports multiple concurrent loading states
- Code matches existing project conventions
</success_criteria>

<output>
After completion, create `.planning/phases/07-ux-polish/07-01-SUMMARY.md`
</output>
