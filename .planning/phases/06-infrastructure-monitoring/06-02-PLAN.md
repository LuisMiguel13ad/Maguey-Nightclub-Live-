---
phase: 06-infrastructure-monitoring
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - maguey-pass-lounge/supabase/functions/_shared/rate-limiter.ts
  - maguey-pass-lounge/supabase/functions/create-checkout-session/index.ts
  - maguey-pass-lounge/supabase/functions/vip/create-payment-intent/index.ts
autonomous: true
user_setup:
  - service: upstash
    why: "Rate limiting requires Redis backend"
    env_vars:
      - name: UPSTASH_REDIS_REST_URL
        source: "Upstash Console -> Database -> REST API -> URL"
      - name: UPSTASH_REDIS_REST_TOKEN
        source: "Upstash Console -> Database -> REST API -> Token"
    dashboard_config:
      - task: "Create Redis database"
        location: "Upstash Console -> Create Database -> Choose region near Supabase"

must_haves:
  truths:
    - "Auth/payment endpoints limited to 20 req/min per IP"
    - "Read endpoints limited to 200 req/min per IP"
    - "Webhook endpoints are exempt from rate limiting"
    - "Blocked requests return 429 with Retry-After header"
    - "Rate limit state persists across function invocations"
  artifacts:
    - path: "maguey-pass-lounge/supabase/functions/_shared/rate-limiter.ts"
      provides: "Shared rate limiting middleware"
      exports: ["checkRateLimit"]
    - path: "maguey-pass-lounge/supabase/functions/create-checkout-session/index.ts"
      provides: "GA checkout with rate limiting"
      contains: "checkRateLimit"
    - path: "maguey-pass-lounge/supabase/functions/vip/create-payment-intent/index.ts"
      provides: "VIP checkout with rate limiting"
      contains: "checkRateLimit"
  key_links:
    - from: "_shared/rate-limiter.ts"
      to: "Upstash Redis"
      via: "HTTP-based Redis client"
      pattern: "Redis\\.fromEnv\\(\\)|Redis.*UPSTASH"
    - from: "create-checkout-session/index.ts"
      to: "_shared/rate-limiter.ts"
      via: "import checkRateLimit"
      pattern: "import.*checkRateLimit.*rate-limiter"
---

<objective>
Implement tiered rate limiting for edge functions using Upstash Redis

Purpose: Protect APIs from abuse while allowing legitimate traffic through
Output: Shared rate-limiter module and rate limiting applied to payment endpoints
</objective>

<execution_context>
@/Users/luismiguel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luismiguel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-infrastructure-monitoring/06-CONTEXT.md
@.planning/phases/06-infrastructure-monitoring/06-RESEARCH.md
@maguey-pass-lounge/supabase/functions/create-checkout-session/index.ts
@maguey-pass-lounge/supabase/functions/vip/create-payment-intent/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create rate-limiter shared module</name>
  <files>maguey-pass-lounge/supabase/functions/_shared/rate-limiter.ts</files>
  <action>
Create the shared rate limiting module at `_shared/rate-limiter.ts`:

1. Import from CDN (per RESEARCH.md):
```typescript
import { Ratelimit } from "https://cdn.skypack.dev/@upstash/ratelimit@latest";
import { Redis } from "https://esm.sh/@upstash/redis@latest";
```

2. Define endpoint types:
```typescript
type EndpointType = 'auth' | 'payment' | 'read' | 'webhook';
```

3. Create lazy-initialized rate limiters (avoid creating Redis clients if env vars missing):
```typescript
function createRedis() {
  return new Redis({
    url: Deno.env.get("UPSTASH_REDIS_REST_URL")!,
    token: Deno.env.get("UPSTASH_REDIS_REST_TOKEN")!,
  });
}

// Cache limiters to avoid recreating on each request
let authLimiter: Ratelimit | null = null;
let paymentLimiter: Ratelimit | null = null;
let readLimiter: Ratelimit | null = null;

function getLimiter(type: EndpointType): Ratelimit | null {
  if (type === 'webhook') return null; // Webhooks exempt

  const redis = createRedis();

  switch (type) {
    case 'auth':
      if (!authLimiter) {
        authLimiter = new Ratelimit({
          redis,
          limiter: Ratelimit.slidingWindow(20, "60 s"),
          prefix: "maguey:auth",
        });
      }
      return authLimiter;
    case 'payment':
      if (!paymentLimiter) {
        paymentLimiter = new Ratelimit({
          redis,
          limiter: Ratelimit.slidingWindow(20, "60 s"),
          prefix: "maguey:payment",
        });
      }
      return paymentLimiter;
    case 'read':
      if (!readLimiter) {
        readLimiter = new Ratelimit({
          redis,
          limiter: Ratelimit.slidingWindow(200, "60 s"),
          prefix: "maguey:read",
        });
      }
      return readLimiter;
  }
}
```

4. Create the checkRateLimit function:
```typescript
export async function checkRateLimit(
  req: Request,
  endpointType: EndpointType
): Promise<{ allowed: boolean; response?: Response }> {
  // Webhooks exempt
  if (endpointType === 'webhook') {
    return { allowed: true };
  }

  // Skip rate limiting if Upstash not configured
  const upstashUrl = Deno.env.get("UPSTASH_REDIS_REST_URL");
  if (!upstashUrl) {
    console.log("[rate-limiter] Upstash not configured, skipping rate limit");
    return { allowed: true };
  }

  const limiter = getLimiter(endpointType);
  if (!limiter) {
    return { allowed: true };
  }

  // Get client IP
  const clientIP = req.headers.get("x-forwarded-for")?.split(",")[0]?.trim()
    || req.headers.get("x-real-ip")
    || "unknown";

  try {
    const { success, remaining, reset } = await limiter.limit(clientIP);

    if (!success) {
      const retryAfter = Math.ceil((reset - Date.now()) / 1000);
      return {
        allowed: false,
        response: new Response(
          JSON.stringify({
            error: "Rate limit exceeded",
            retryAfter,
          }),
          {
            status: 429,
            headers: {
              "Content-Type": "application/json",
              "Retry-After": retryAfter.toString(),
              "X-RateLimit-Remaining": remaining.toString(),
              "X-RateLimit-Reset": reset.toString(),
            },
          }
        ),
      };
    }

    return { allowed: true };
  } catch (error) {
    // Fail open - don't block requests if rate limiting fails
    console.error("[rate-limiter] Error checking rate limit:", error);
    return { allowed: true };
  }
}
```
  </action>
  <verify>File exists at path and exports checkRateLimit function</verify>
  <done>Rate limiter shared module created with tiered limits for auth (20/min), payment (20/min), and read (200/min) endpoints</done>
</task>

<task type="auto">
  <name>Task 2: Apply rate limiting to payment endpoints</name>
  <files>
    maguey-pass-lounge/supabase/functions/create-checkout-session/index.ts
    maguey-pass-lounge/supabase/functions/vip/create-payment-intent/index.ts
  </files>
  <action>
Add rate limiting to payment endpoints:

**For create-checkout-session/index.ts:**

1. Add import at top:
```typescript
import { checkRateLimit } from "../_shared/rate-limiter.ts";
```

2. Add rate limit check early in handler (after CORS preflight):
```typescript
// Rate limiting
const { allowed, response: rateLimitResponse } = await checkRateLimit(req, 'payment');
if (!allowed) {
  return rateLimitResponse!;
}
```

**For vip/create-payment-intent/index.ts:**

1. Add import at top:
```typescript
import { checkRateLimit } from "../../_shared/rate-limiter.ts";
```

2. Add rate limit check early in handler (after CORS preflight):
```typescript
// Rate limiting
const { allowed, response: rateLimitResponse } = await checkRateLimit(req, 'payment');
if (!allowed) {
  return rateLimitResponse!;
}
```

Note: Webhook endpoints (stripe-webhook, vip/webhook, resend-webhook) should NOT have rate limiting added - they are exempt per CONTEXT.md.
  </action>
  <verify>Both files import checkRateLimit and call it before processing</verify>
  <done>Payment endpoints protected with 20 req/min rate limit per IP</done>
</task>

<task type="auto">
  <name>Task 3: Deploy and test rate limiting</name>
  <files>None (verification only)</files>
  <action>
Deploy updated functions and test rate limiting:

1. Deploy both functions:
```bash
cd maguey-pass-lounge
supabase functions deploy create-checkout-session
supabase functions deploy vip/create-payment-intent
```

2. Test rate limiting behavior (if Upstash configured):
   - Send 21 requests in 1 minute to create-checkout-session
   - 21st request should return 429 with Retry-After header

3. Verify webhook endpoints still work without rate limiting:
   - stripe-webhook should not check rate limits

4. If Upstash not configured:
   - Functions should work normally (fail-open pattern)
   - Console should log "Upstash not configured, skipping rate limit"
  </action>
  <verify>Functions deploy successfully and rate limiting is active when Upstash is configured</verify>
  <done>Rate limiting deployed to production with fail-open pattern</done>
</task>

</tasks>

<verification>
- [ ] `_shared/rate-limiter.ts` exists with checkRateLimit export
- [ ] Rate limiter uses sliding window algorithm (20/min for auth/payment, 200/min for read)
- [ ] create-checkout-session imports and uses checkRateLimit
- [ ] vip/create-payment-intent imports and uses checkRateLimit
- [ ] Rate limiting returns 429 with Retry-After header when exceeded
- [ ] Webhook endpoints (stripe-webhook, vip/webhook) have NO rate limiting
- [ ] Fail-open pattern: requests allowed if Upstash unavailable
- [ ] Functions deploy successfully
</verification>

<success_criteria>
1. Payment endpoints return 429 after 20 requests in 1 minute from same IP
2. 429 response includes `Retry-After` header with seconds to wait
3. Webhook endpoints are exempt and never rate limited
4. System works without Upstash (graceful degradation)
</success_criteria>

<output>
After completion, create `.planning/phases/06-infrastructure-monitoring/06-02-SUMMARY.md`
</output>
