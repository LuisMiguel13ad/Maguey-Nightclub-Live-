---
phase: 03-scanner-system-hardening
plan: 04
type: execute
wave: 2
depends_on: ["03-01", "03-02"]
files_modified:
  - maguey-gate-scanner/src/lib/simple-scanner.ts
  - maguey-gate-scanner/src/pages/Scanner.tsx
autonomous: true

must_haves:
  truths:
    - "Already-scanned rejection shows staff name, gate, and time"
    - "Wrong-event rejection shows the correct event date"
    - "Scanner validates against offline cache when network unavailable"
    - "Unknown tickets in offline mode are accepted with warning"
    - "Scan logs include staff display name for later lookup"
  artifacts:
    - path: "maguey-gate-scanner/src/lib/simple-scanner.ts"
      provides: "Enhanced scan result with detailed rejection info"
      exports: ["ScanResult", "scanTicket", "findTicket"]
  key_links:
    - from: "simple-scanner.ts"
      to: "offline-ticket-cache.ts"
      via: "validateOffline for offline validation"
      pattern: "validateOffline"
    - from: "Scanner.tsx"
      to: "RejectionOverlay"
      via: "passes rejectionDetails from scan result"
      pattern: "rejectionDetails.*previousScan"
---

<objective>
Enhance scanner service with detailed rejection info and offline cache integration

Purpose: Staff need specific error details when rejecting tickets (who scanned it, when, what gate). Scanner must also work offline by validating against the cached ticket list.

Output: Enhanced simple-scanner.ts with detailed ScanResult and offline validation path
</objective>

<execution_context>
@/Users/luismiguel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luismiguel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-scanner-system-hardening/03-CONTEXT.md
@.planning/phases/03-scanner-system-hardening/03-RESEARCH.md

@maguey-gate-scanner/src/lib/simple-scanner.ts
@maguey-gate-scanner/src/lib/offline-ticket-cache.ts
@maguey-gate-scanner/src/lib/offline-queue-service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance ScanResult interface with detailed rejection info</name>
  <files>maguey-gate-scanner/src/lib/simple-scanner.ts</files>
  <action>
Update the ScanResult interface in simple-scanner.ts to include detailed rejection information:

**1. Update ScanResult interface:**
```typescript
export interface ScanResult {
  success: boolean;
  ticket: Ticket | null;
  message: string;
  alreadyScanned?: boolean;

  // New fields for detailed rejection info
  rejectionReason?: 'already_used' | 'wrong_event' | 'invalid' | 'expired' | 'tampered' | 'not_found' | 'offline_unknown';
  rejectionDetails?: {
    previousScan?: {
      staff: string;      // Display name or "Unknown Staff"
      gate: string;       // Device ID or "Unknown Gate"
      time: string;       // Formatted time "2:30 PM"
    };
    wrongEventDate?: string;  // "Saturday Feb 1st"
    wrongEventName?: string;  // Event name for context
  };

  // New fields for offline mode
  offlineValidated?: boolean;  // True if validated against cache (not server)
  offlineWarning?: string;     // Warning message for unknown tickets in offline mode
}
```

**2. Update the already-scanned error handling** (around line 230-238):
```typescript
if (isAlreadyScanned) {
  // Format the previous scan time
  const scannedTime = ticket.scanned_at
    ? new Date(ticket.scanned_at).toLocaleTimeString('en-US', {
        hour: 'numeric',
        minute: '2-digit',
        hour12: true
      })
    : 'unknown time';

  // Get staff name - for now use scanned_by ID, will be enhanced with user lookup
  // Note: scan_logs.scanned_by contains user ID, we'd need a join for name
  const staffName = 'Staff'; // Placeholder - enhance in next iteration

  // Get gate/device info from scan_logs if available
  const gateName = 'Gate'; // Placeholder - could use device_id from scanner

  return {
    success: false,
    ticket,
    message: `Already scanned at ${scannedTime}`,
    alreadyScanned: true,
    rejectionReason: 'already_used',
    rejectionDetails: {
      previousScan: {
        staff: staffName,
        gate: gateName,
        time: scannedTime,
      },
    },
  };
}
```

**3. Add a helper function to get staff display name:**
```typescript
async function getStaffDisplayName(userId: string | null): Promise<string> {
  if (!userId) return 'Unknown Staff';

  try {
    // Try to get user profile/name from auth metadata or profiles table
    const { data } = await supabase
      .from('profiles')
      .select('full_name, email')
      .eq('id', userId)
      .single();

    if (data?.full_name) return data.full_name;
    if (data?.email) return data.email.split('@')[0];
    return 'Staff';
  } catch {
    return 'Staff';
  }
}
```

**4. Update wrong-event error** to include event date info:
```typescript
// In the event filter check (if implementing event-specific scanning)
if (eventFilter && ticket.event_name !== eventFilter) {
  // Try to get the event date for the ticket's actual event
  let wrongEventDate = ticket.event_name || 'a different event';

  // If we have event_id, could fetch the actual date
  // For now, use event_name as the identifier

  return {
    success: false,
    ticket,
    message: `This ticket is for ${wrongEventDate}`,
    rejectionReason: 'wrong_event',
    rejectionDetails: {
      wrongEventName: ticket.event_name,
      wrongEventDate: wrongEventDate,
    },
  };
}
```
  </action>
  <verify>Interface updated: `grep -A 20 "export interface ScanResult" maguey-gate-scanner/src/lib/simple-scanner.ts | grep -c "rejectionReason"`</verify>
  <done>ScanResult interface includes rejectionReason and rejectionDetails fields</done>
</task>

<task type="auto">
  <name>Task 2: Add offline validation path using ticket cache</name>
  <files>maguey-gate-scanner/src/lib/simple-scanner.ts</files>
  <action>
Add offline validation logic that uses the ticket cache:

**1. Import the cache service:**
```typescript
import { validateOffline, markAsScannedOffline, CachedTicket } from './offline-ticket-cache';
```

**2. Create a new function for offline scanning:**
```typescript
/**
 * Scan a ticket while offline - validates against local cache
 * Per context decision: Accept unknown tickets with warning, first-scan-wins for conflicts
 */
export async function scanTicketOffline(
  input: string,
  userId?: string,
  eventId?: string
): Promise<ScanResult> {
  // Parse input for QR signature verification
  const parsed = await parseQrInput(input);

  if (parsed.error) {
    return {
      success: false,
      ticket: null,
      message: parsed.error,
      rejectionReason: 'invalid',
    };
  }

  if (!parsed.token) {
    return {
      success: false,
      ticket: null,
      message: 'Invalid input - no ticket ID found',
      rejectionReason: 'invalid',
    };
  }

  // Validate against offline cache
  const cacheResult = await validateOffline(parsed.token, eventId);

  if (cacheResult.status === 'not_in_cache') {
    // Per context decision: Accept unknown tickets with warning
    // They'll be verified when sync happens
    console.log('[simple-scanner] Offline: Ticket not in cache, accepting with warning');

    return {
      success: true,
      ticket: null, // No ticket data available offline
      message: 'Accepted (verify when online)',
      offlineValidated: true,
      offlineWarning: 'Ticket not in local cache. Will verify when connection restored.',
    };
  }

  if (cacheResult.status === 'wrong_event') {
    return {
      success: false,
      ticket: null,
      message: `This ticket is for a different event`,
      rejectionReason: 'wrong_event',
      offlineValidated: true,
    };
  }

  if (cacheResult.status === 'scanned') {
    // Already scanned - show cached scan info
    const cachedTicket = cacheResult.ticket!;
    const scannedTime = cachedTicket.scannedAt
      ? new Date(cachedTicket.scannedAt).toLocaleTimeString('en-US', {
          hour: 'numeric',
          minute: '2-digit',
          hour12: true
        })
      : 'earlier';

    return {
      success: false,
      ticket: convertCachedToTicket(cachedTicket),
      message: `Already scanned at ${scannedTime}`,
      alreadyScanned: true,
      rejectionReason: 'already_used',
      rejectionDetails: {
        previousScan: {
          staff: cachedTicket.scannedByName || 'Staff',
          gate: 'This device',
          time: scannedTime,
        },
      },
      offlineValidated: true,
    };
  }

  // Valid ticket - mark as scanned in cache
  const cachedTicket = cacheResult.ticket!;
  await markAsScannedOffline(cachedTicket.ticketId, userId);

  return {
    success: true,
    ticket: convertCachedToTicket(cachedTicket),
    message: 'Valid ticket - Entry granted (offline)',
    offlineValidated: true,
  };
}

/**
 * Convert CachedTicket to Ticket interface for consistency
 */
function convertCachedToTicket(cached: CachedTicket): Ticket {
  return {
    id: cached.ticketId,
    ticket_id: cached.ticketId,
    guest_name: cached.guestName || null,
    ticket_type: cached.ticketType,
    event_name: null, // Not stored in cache
    event_id: cached.eventId,
    is_used: cached.status === 'scanned',
    status: cached.status,
    scanned_at: cached.scannedAt || null,
    // Other fields from Ticket interface set to null/defaults
    qr_code_data: cached.qrToken,
    price: null,
    purchase_date: null,
    created_at: null,
    updated_at: null,
  } as Ticket;
}
```

**3. Export the new function:**
Make sure to export scanTicketOffline from the module.
  </action>
  <verify>Function exported: `grep -c "export.*scanTicketOffline" maguey-gate-scanner/src/lib/simple-scanner.ts`</verify>
  <done>scanTicketOffline function validates against local cache when network unavailable</done>
</task>

<task type="auto">
  <name>Task 3: Update Scanner.tsx to use offline validation and enhanced error details</name>
  <files>maguey-gate-scanner/src/pages/Scanner.tsx</files>
  <action>
Update Scanner.tsx to leverage the enhanced scan result:

**1. Import the offline scan function:**
```typescript
import { scanTicket, scanTicketOffline } from "@/lib/simple-scanner";
import { ensureCacheIsFresh } from "@/lib/offline-ticket-cache";
```

**2. Update processScan to use offline validation when offline:**
Replace the offline handling section (around line 211-233):

```typescript
// If offline, use local cache validation
if (!isOnline) {
  // Validate against cache instead of just queueing
  const result = await scanTicketOffline(input.trim(), user?.id, selectedEventId || undefined);

  // Guard: Don't update state if component unmounted
  if (!mountedRef.current) return;

  if (result.success) {
    // Queue for sync when back online
    await queueScan(input.trim(), user?.id, {
      ticketIdString: input.trim(),
      scanMetadata: {
        eventId: selectedEventId || undefined,
        ticketType: result.ticket?.ticket_type,
        attendeeName: result.ticket?.guest_name || undefined,
      },
    });

    setScanState({
      status: "success",
      ticket: result.ticket,
      message: result.message,
      // Pass offline warning if present
    });

    // Show toast if there's an offline warning
    if (result.offlineWarning) {
      toast({
        title: "Offline Scan",
        description: result.offlineWarning,
        variant: "default",
      });
    }
  } else {
    setScanState({
      status: result.alreadyScanned ? "already_scanned" : "error",
      ticket: result.ticket,
      message: result.message,
      rejectionReason: result.rejectionReason,
      rejectionDetails: result.rejectionDetails,
    });
  }

  setManualInput("");
  setIsProcessing(false);
  return;
}
```

**3. Update the online scan result handling** to pass through rejection details:
```typescript
if (result.success) {
  // ... existing success handling
} else if (result.alreadyScanned) {
  setScanState({
    status: "already_scanned",
    ticket: result.ticket,
    message: result.message,
    rejectionReason: result.rejectionReason || 'already_used',
    rejectionDetails: result.rejectionDetails,
  });
} else {
  setScanState({
    status: "error",
    ticket: null,
    message: result.message,
    rejectionReason: result.rejectionReason || 'invalid',
    rejectionDetails: result.rejectionDetails,
  });
}
```

**4. Trigger cache sync when event is selected:**
```typescript
// In the event selection handler or useEffect watching selectedEventId
useEffect(() => {
  if (selectedEventId && navigator.onLine) {
    ensureCacheIsFresh(selectedEventId).then(result => {
      if (result.status === 'refreshed') {
        console.log('[Scanner] Refreshed ticket cache:', result.ticketCount, 'tickets');
      }
    });
  }
}, [selectedEventId]);
```

**5. Ensure RejectionOverlay receives the details:**
The overlay integration from 03-01 should already pass rejectionDetails. Verify the props are correctly mapped:
```tsx
<RejectionOverlay
  reason={scanState.rejectionReason || 'invalid'}
  details={{
    previousScan: scanState.rejectionDetails?.previousScan,
    wrongEventDate: scanState.rejectionDetails?.wrongEventDate,
    message: scanState.message
  }}
  onDismiss={handleScanAnother}
/>
```
  </action>
  <verify>Build passes: `cd maguey-gate-scanner && npm run build`</verify>
  <done>Scanner.tsx uses offline validation and passes detailed rejection info to overlays</done>
</task>

</tasks>

<verification>
1. Build completes without errors
2. ScanResult interface includes rejectionReason and rejectionDetails
3. scanTicketOffline function exists and is exported
4. Scanner.tsx calls scanTicketOffline when navigator.onLine is false
5. Rejection overlays receive and display staff/gate/time details
</verification>

<success_criteria>
1. Already-scanned rejection shows: "Scanned by [Staff] at [Gate], [Time]"
2. Wrong-event rejection shows: "This ticket is for [Event Date]"
3. Offline scanning validates against local cache
4. Unknown tickets in offline mode accepted with warning toast
5. Scans are queued for sync when offline
6. Cache auto-refreshes when event is selected
7. All rejection details flow through to RejectionOverlay
</success_criteria>

<output>
After completion, create `.planning/phases/03-scanner-system-hardening/03-04-SUMMARY.md`
</output>
