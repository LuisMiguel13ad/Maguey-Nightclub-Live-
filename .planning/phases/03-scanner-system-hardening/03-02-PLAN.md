---
phase: 03-scanner-system-hardening
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - maguey-gate-scanner/src/lib/offline-ticket-cache.ts
autonomous: true

must_haves:
  truths:
    - "Ticket list can be downloaded for an event"
    - "Tickets can be validated locally when offline"
    - "Cache returns 'not_in_cache' for unknown tickets"
    - "Cache auto-syncs when event is selected"
    - "Old event caches are automatically cleaned up"
  artifacts:
    - path: "maguey-gate-scanner/src/lib/offline-ticket-cache.ts"
      provides: "Ticket caching service using Dexie.js"
      exports: ["syncTicketCache", "validateOffline", "getCacheStatus", "clearEventCache"]
  key_links:
    - from: "offline-ticket-cache.ts"
      to: "supabase"
      via: "fetch tickets query"
      pattern: "supabase.*from.*tickets"
    - from: "offline-ticket-cache.ts"
      to: "Dexie"
      via: "IndexedDB storage"
      pattern: "extends Dexie"
---

<objective>
Create offline ticket cache service for local validation when network is unavailable

Purpose: Scanner must validate tickets even without network. Caching the ticket list in IndexedDB allows local validation with immediate accept/reject feedback.

Output: offline-ticket-cache.ts service that syncs ticket data and validates scans locally
</objective>

<execution_context>
@/Users/luismiguel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luismiguel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-scanner-system-hardening/03-CONTEXT.md
@.planning/phases/03-scanner-system-hardening/03-RESEARCH.md

@maguey-gate-scanner/src/lib/offline-queue-service.ts
@maguey-gate-scanner/src/lib/simple-scanner.ts
@maguey-gate-scanner/src/lib/supabase.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Dexie database schema for ticket cache</name>
  <files>maguey-gate-scanner/src/lib/offline-ticket-cache.ts</files>
  <action>
Create offline-ticket-cache.ts following the pattern from offline-queue-service.ts:

**1. Imports:**
```typescript
import Dexie, { Table } from 'dexie';
import { supabase } from './supabase';
```

**2. Type definitions:**
```typescript
export interface CachedTicket {
  ticketId: string;       // Primary key
  eventId: string;
  qrToken: string;        // For lookup during scan
  qrSignature?: string;
  status: 'valid' | 'scanned';
  guestName?: string;
  ticketType: string;
  scannedAt?: string;
  scannedBy?: string;     // User ID who scanned
  scannedByName?: string; // Display name for UI
  syncedAt: string;       // When this cache entry was updated
}

export interface CacheMetadata {
  eventId: string;        // Primary key
  eventName: string;
  lastSyncAt: string;
  ticketCount: number;
  totalCapacity: number;
  scannedCount: number;
}
```

**3. Dexie database class:**
```typescript
class TicketCacheDatabase extends Dexie {
  cachedTickets!: Table<CachedTicket, string>;
  cacheMetadata!: Table<CacheMetadata, string>;

  constructor() {
    super('TicketCacheDatabase');
    this.version(1).stores({
      cachedTickets: 'ticketId, eventId, qrToken, status',
      cacheMetadata: 'eventId',
    });
  }
}

const db = new TicketCacheDatabase();
```

Note: Use 'ticketId' as primary key (not 'id') to match the data structure. Index on qrToken for fast lookups during scan validation.
  </action>
  <verify>File created: `test -f maguey-gate-scanner/src/lib/offline-ticket-cache.ts && echo "exists"`</verify>
  <done>Dexie database schema created with cachedTickets and cacheMetadata tables</done>
</task>

<task type="auto">
  <name>Task 2: Implement sync and validation functions</name>
  <files>maguey-gate-scanner/src/lib/offline-ticket-cache.ts</files>
  <action>
Add the following functions to offline-ticket-cache.ts:

**1. syncTicketCache - Download tickets for an event:**
```typescript
export async function syncTicketCache(eventId: string): Promise<{
  success: boolean;
  ticketCount: number;
  error?: string;
}> {
  try {
    // Fetch event info
    const { data: eventData, error: eventError } = await supabase
      .from('events')
      .select('id, name')
      .eq('id', eventId)
      .single();

    if (eventError) throw eventError;

    // Fetch all tickets for this event
    // Include user info for scanned_by display name
    const { data: tickets, error: ticketsError } = await supabase
      .from('tickets')
      .select(`
        id,
        ticket_id,
        qr_code_data,
        status,
        is_used,
        guest_name,
        ticket_type,
        scanned_at,
        scanned_by
      `)
      .eq('event_id', eventId);

    if (ticketsError) throw ticketsError;

    // Get scanned count
    const scannedCount = (tickets || []).filter(t => t.is_used || t.status === 'scanned').length;

    // Clear existing cache for this event
    await db.cachedTickets.where('eventId').equals(eventId).delete();

    // Insert new cache entries
    const now = new Date().toISOString();
    const cacheEntries: CachedTicket[] = (tickets || []).map(t => ({
      ticketId: t.id,
      eventId,
      qrToken: t.qr_code_data || t.ticket_id,
      status: (t.is_used || t.status === 'scanned') ? 'scanned' : 'valid',
      guestName: t.guest_name || undefined,
      ticketType: t.ticket_type || 'General',
      scannedAt: t.scanned_at || undefined,
      scannedBy: t.scanned_by || undefined,
      syncedAt: now,
    }));

    await db.cachedTickets.bulkPut(cacheEntries);

    // Update metadata
    await db.cacheMetadata.put({
      eventId,
      eventName: eventData.name,
      lastSyncAt: now,
      ticketCount: cacheEntries.length,
      totalCapacity: cacheEntries.length, // Could be enhanced to fetch from ticket_types
      scannedCount,
    });

    console.log('[offline-ticket-cache] Synced', cacheEntries.length, 'tickets for event', eventId);
    return { success: true, ticketCount: cacheEntries.length };
  } catch (error: any) {
    console.error('[offline-ticket-cache] Sync failed:', error);
    return { success: false, ticketCount: 0, error: error.message };
  }
}
```

**2. validateOffline - Check ticket against cache:**
```typescript
export async function validateOffline(qrToken: string, eventId?: string): Promise<{
  status: 'valid' | 'scanned' | 'not_in_cache' | 'wrong_event';
  ticket?: CachedTicket;
}> {
  // Try to find by qrToken
  const ticket = await db.cachedTickets.where('qrToken').equals(qrToken).first();

  if (!ticket) {
    return { status: 'not_in_cache' };
  }

  // Check event match if eventId filter is provided
  if (eventId && ticket.eventId !== eventId) {
    return { status: 'wrong_event', ticket };
  }

  return { status: ticket.status, ticket };
}
```

**3. markAsScannedOffline - Update local cache when scanning offline:**
```typescript
export async function markAsScannedOffline(
  ticketId: string,
  scannedBy?: string
): Promise<boolean> {
  try {
    const now = new Date().toISOString();
    await db.cachedTickets.update(ticketId, {
      status: 'scanned',
      scannedAt: now,
      scannedBy,
      syncedAt: now,
    });

    // Update scanned count in metadata
    const ticket = await db.cachedTickets.get(ticketId);
    if (ticket) {
      const metadata = await db.cacheMetadata.get(ticket.eventId);
      if (metadata) {
        await db.cacheMetadata.update(ticket.eventId, {
          scannedCount: metadata.scannedCount + 1,
        });
      }
    }

    return true;
  } catch (error) {
    console.error('[offline-ticket-cache] Failed to mark as scanned:', error);
    return false;
  }
}
```

**4. getCacheStatus - Get cache info for UI:**
```typescript
export async function getCacheStatus(eventId: string): Promise<CacheMetadata | null> {
  return await db.cacheMetadata.get(eventId);
}

export async function getAllCachedEvents(): Promise<CacheMetadata[]> {
  return await db.cacheMetadata.toArray();
}
```

**5. clearEventCache - Remove old event caches:**
```typescript
export async function clearEventCache(eventId: string): Promise<void> {
  await db.cachedTickets.where('eventId').equals(eventId).delete();
  await db.cacheMetadata.delete(eventId);
  console.log('[offline-ticket-cache] Cleared cache for event', eventId);
}

// Clear caches older than 24 hours per context decision
export async function clearOldCaches(): Promise<number> {
  const oneDayAgo = new Date();
  oneDayAgo.setHours(oneDayAgo.getHours() - 24);
  const cutoff = oneDayAgo.toISOString();

  const oldEvents = await db.cacheMetadata
    .filter(m => m.lastSyncAt < cutoff)
    .toArray();

  for (const event of oldEvents) {
    await clearEventCache(event.eventId);
  }

  console.log('[offline-ticket-cache] Cleared', oldEvents.length, 'old event caches');
  return oldEvents.length;
}
```

**6. getCheckedInCount - For check-in counter UI:**
```typescript
export async function getCheckedInCount(eventId: string): Promise<{
  checkedIn: number;
  total: number;
}> {
  const metadata = await db.cacheMetadata.get(eventId);
  if (!metadata) {
    return { checkedIn: 0, total: 0 };
  }
  return {
    checkedIn: metadata.scannedCount,
    total: metadata.ticketCount,
  };
}
```
  </action>
  <verify>Build passes: `cd maguey-gate-scanner && npm run build`</verify>
  <done>All cache functions implemented: sync, validate, mark scanned, clear old caches</done>
</task>

<task type="auto">
  <name>Task 3: Add auto-sync hook for event selection</name>
  <files>maguey-gate-scanner/src/lib/offline-ticket-cache.ts</files>
  <action>
Add a convenience hook/function for Scanner.tsx integration:

**1. Create auto-sync function with smart caching:**
```typescript
// Check if cache needs refresh (older than 5 minutes)
const CACHE_REFRESH_INTERVAL_MS = 5 * 60 * 1000; // 5 minutes

export async function ensureCacheIsFresh(eventId: string): Promise<{
  status: 'fresh' | 'refreshed' | 'failed';
  ticketCount: number;
}> {
  const metadata = await db.cacheMetadata.get(eventId);

  if (metadata) {
    const lastSync = new Date(metadata.lastSyncAt).getTime();
    const now = Date.now();

    if (now - lastSync < CACHE_REFRESH_INTERVAL_MS) {
      // Cache is fresh enough
      return { status: 'fresh', ticketCount: metadata.ticketCount };
    }
  }

  // Cache is stale or doesn't exist - refresh
  if (!navigator.onLine) {
    // Can't refresh while offline, use existing cache
    if (metadata) {
      return { status: 'fresh', ticketCount: metadata.ticketCount };
    }
    return { status: 'failed', ticketCount: 0 };
  }

  const result = await syncTicketCache(eventId);
  return {
    status: result.success ? 'refreshed' : 'failed',
    ticketCount: result.ticketCount,
  };
}
```

**2. Export a React-friendly hook pattern (optional):**
```typescript
// Listener for cache updates (for real-time UI updates)
type CacheListener = (eventId: string, metadata: CacheMetadata) => void;
const listeners: CacheListener[] = [];

export function subscribeToCacheUpdates(listener: CacheListener): () => void {
  listeners.push(listener);
  return () => {
    const index = listeners.indexOf(listener);
    if (index > -1) listeners.splice(index, 1);
  };
}

// Call after sync operations
function notifyListeners(eventId: string, metadata: CacheMetadata) {
  listeners.forEach(l => l(eventId, metadata));
}
```

Update syncTicketCache to call notifyListeners after successful sync.
  </action>
  <verify>All exports present: `grep -E "export (async )?function" maguey-gate-scanner/src/lib/offline-ticket-cache.ts | wc -l` should show 8+ functions</verify>
  <done>Auto-sync function ensures cache freshness, listener pattern available for UI updates</done>
</task>

</tasks>

<verification>
1. Build completes without errors
2. offline-ticket-cache.ts exports all required functions
3. Dexie database schema matches CachedTicket and CacheMetadata interfaces
4. syncTicketCache fetches from supabase and stores in IndexedDB
5. validateOffline returns correct status for cached/uncached tickets
</verification>

<success_criteria>
1. syncTicketCache downloads and stores ticket list for an event
2. validateOffline returns 'valid', 'scanned', or 'not_in_cache'
3. markAsScannedOffline updates local cache status
4. Cache metadata tracks ticket count and last sync time
5. clearOldCaches removes caches older than 24 hours
6. ensureCacheIsFresh auto-refreshes stale caches when online
</success_criteria>

<output>
After completion, create `.planning/phases/03-scanner-system-hardening/03-02-SUMMARY.md`
</output>
