---
phase: 08-ga-e2e-testing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - e2e/cypress.config.ts
  - e2e/support/e2e.ts
  - e2e/support/index.d.ts
  - e2e/support/commands/auth.ts
  - e2e/support/commands/purchase.ts
  - e2e/support/commands/scan.ts
  - e2e/support/commands/db.ts
  - e2e/fixtures/stripe-cards.json
  - e2e/tsconfig.json
  - package.json
autonomous: true

must_haves:
  truths:
    - "Cypress is installed and configured at project root"
    - "Custom commands exist for login, purchase, scan, and DB operations"
    - "Cypress can run with npx cypress open"
  artifacts:
    - path: "e2e/cypress.config.ts"
      provides: "Cypress configuration with cross-origin support"
      contains: "cy.origin"
    - path: "e2e/support/commands/auth.ts"
      provides: "Login command with cy.session"
      contains: "Cypress.Commands.add"
    - path: "e2e/support/commands/purchase.ts"
      provides: "Purchase and Stripe payment commands"
      contains: "fillElementsInput"
    - path: "e2e/support/commands/db.ts"
      provides: "Database verification tasks"
      contains: "cy.task"
  key_links:
    - from: "e2e/support/e2e.ts"
      to: "e2e/support/commands/*.ts"
      via: "import statements"
      pattern: "import.*commands"
    - from: "e2e/cypress.config.ts"
      to: "@supabase/supabase-js"
      via: "setupNodeEvents tasks"
      pattern: "createClient"
---

<objective>
Set up Cypress E2E testing infrastructure with custom commands for cross-app GA ticket flow testing.

Purpose: Establish the foundation for all E2E tests - Cypress config, folder structure, custom commands for auth, purchase, scan, and database verification. This enables the complete GA flow testing from purchase on maguey-pass-lounge to scanning on maguey-gate-scanner.

Output: Working Cypress setup with reusable custom commands ready for test specs.
</objective>

<execution_context>
@/Users/luismiguel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luismiguel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-ga-e2e-testing/08-CONTEXT.md
@.planning/phases/08-ga-e2e-testing/08-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Cypress and dependencies</name>
  <files>
    package.json
    e2e/tsconfig.json
  </files>
  <action>
Install Cypress and required plugins at the project root:

```bash
npm install --save-dev cypress @cypress/grep cypress-plugin-stripe-elements jsqr start-server-and-test
```

Create e2e/tsconfig.json for TypeScript support:
```json
{
  "compilerOptions": {
    "target": "ES2020",
    "lib": ["ES2020", "DOM"],
    "types": ["cypress", "node"],
    "moduleResolution": "node",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true
  },
  "include": ["**/*.ts"]
}
```

Update root package.json to add E2E scripts:
```json
"scripts": {
  "cy:open": "cypress open --config-file e2e/cypress.config.ts",
  "cy:run": "cypress run --config-file e2e/cypress.config.ts",
  "e2e": "start-server-and-test 'npm run dev --workspace=maguey-pass-lounge & npm run dev --workspace=maguey-gate-scanner' 'http://localhost:3016|http://localhost:3015' 'npm run cy:run'",
  "e2e:open": "npm run cy:open"
}
```
  </action>
  <verify>
Run `npx cypress --version` to confirm Cypress is installed.
Run `npm run cy:open` and verify Cypress opens (close it immediately after).
  </verify>
  <done>Cypress 15.x installed with all plugins, scripts added to package.json, e2e/tsconfig.json created</done>
</task>

<task type="auto">
  <name>Task 2: Create Cypress configuration with cross-origin support</name>
  <files>
    e2e/cypress.config.ts
    e2e/support/e2e.ts
    e2e/support/index.d.ts
    e2e/fixtures/stripe-cards.json
  </files>
  <action>
Create e2e/cypress.config.ts with full configuration per RESEARCH.md:

```typescript
import { defineConfig } from 'cypress';
import { createClient } from '@supabase/supabase-js';

export default defineConfig({
  e2e: {
    baseUrl: 'http://localhost:3016', // maguey-pass-lounge
    supportFile: 'e2e/support/e2e.ts',
    specPattern: 'e2e/specs/**/*.cy.ts',

    // Video/screenshot on failure only
    video: true,
    screenshotOnRunFailure: true,
    trashAssetsBeforeRuns: true,

    // Retry config for flaky tests
    retries: {
      runMode: 2,
      openMode: 0,
    },

    // Required for Stripe iframe handling
    chromeWebSecurity: false,

    // Timeouts
    defaultCommandTimeout: 10000,
    pageLoadTimeout: 30000,
    requestTimeout: 10000,

    // Environment variables
    env: {
      SUPABASE_URL: process.env.VITE_SUPABASE_URL,
      SUPABASE_SERVICE_ROLE_KEY: process.env.SUPABASE_SERVICE_ROLE_KEY,
      SCANNER_URL: 'http://localhost:3015',
      SCANNER_EMAIL: process.env.SCANNER_TEST_EMAIL || 'staff@maguey.test',
      SCANNER_PASSWORD: process.env.SCANNER_TEST_PASSWORD || 'testpassword123',
    },

    setupNodeEvents(on, config) {
      const supabaseUrl = config.env.SUPABASE_URL || process.env.VITE_SUPABASE_URL;
      const supabaseKey = config.env.SUPABASE_SERVICE_ROLE_KEY || process.env.SUPABASE_SERVICE_ROLE_KEY;

      // Only create client if we have credentials
      const supabase = supabaseUrl && supabaseKey
        ? createClient(supabaseUrl, supabaseKey)
        : null;

      on('task', {
        // Health check all services
        async healthCheck() {
          const checks = { db: false, stripe: true, edgeFunctions: true };

          if (supabase) {
            const { error } = await supabase.from('events').select('id').limit(1);
            checks.db = !error;
          }

          return checks;
        },

        // Verify ticket was created
        async verifyTicketCreated(ticketId: string) {
          if (!supabase) return { data: null, error: 'No Supabase client' };
          return supabase.from('tickets').select('*').eq('id', ticketId).single();
        },

        // Verify ticket by QR code token
        async verifyTicketByToken(qrCodeToken: string) {
          if (!supabase) return { data: null, error: 'No Supabase client' };
          return supabase.from('tickets').select('*').eq('qr_code_token', qrCodeToken).single();
        },

        // Verify email was queued
        async verifyEmailQueued(ticketId: string) {
          if (!supabase) return [];
          const { data } = await supabase
            .from('email_queue')
            .select('*')
            .eq('related_id', ticketId);
          return data || [];
        },

        // Verify ticket was scanned
        async verifyTicketScanned(ticketId: string) {
          if (!supabase) return { data: null, error: 'No Supabase client' };
          return supabase.from('tickets').select('*').eq('id', ticketId).single();
        },

        // Get upcoming event for testing
        async getTestEvent() {
          if (!supabase) return null;
          const { data } = await supabase
            .from('events')
            .select('*')
            .gte('event_datetime', new Date().toISOString())
            .eq('status', 'published')
            .order('event_datetime', { ascending: true })
            .limit(1)
            .single();
          return data;
        },

        // Cleanup test data by test run ID
        async cleanupTestData(testRunId: string) {
          if (!supabase) return null;
          // Delete tickets with test emails
          await supabase.from('tickets').delete().ilike('attendee_email', `%+${testRunId}@%`);
          return null;
        },

        // Create test ticket for scan tests
        async createTestTicket(eventId: string) {
          if (!supabase) return null;
          const testRunId = Date.now().toString();
          const qrToken = `TEST-${testRunId}-${Math.random().toString(36).substring(7)}`;

          const { data, error } = await supabase
            .from('tickets')
            .insert({
              event_id: eventId,
              ticket_type_id: null, // Will need to get a valid ticket type
              attendee_email: `test+${testRunId}@maguey.test`,
              attendee_name: 'Test User',
              qr_code_token: qrToken,
              status: 'issued',
              price_paid: 0,
            })
            .select()
            .single();

          if (error) {
            console.error('Failed to create test ticket:', error);
            return null;
          }
          return data;
        },

        // Log message (for debugging)
        log(message: string) {
          console.log(message);
          return null;
        },
      });

      // Delete videos for passing specs to save space
      on('after:spec', (spec, results) => {
        if (results && results.video) {
          const failures = results.tests?.some((test) =>
            test.attempts?.some((attempt) => attempt.state === 'failed')
          );
          if (!failures) {
            const fs = require('fs');
            try {
              fs.unlinkSync(results.video);
            } catch (e) {
              // Ignore if video doesn't exist
            }
          }
        }
      });

      return config;
    },
  },
});
```

Create e2e/support/e2e.ts (support file that imports commands):
```typescript
// Import commands
import './commands/auth';
import './commands/purchase';
import './commands/scan';
import './commands/db';

// Import Stripe plugin
import 'cypress-plugin-stripe-elements';

// Hide fetch/XHR logs in command log (less noise)
const app = window.top;
if (app && !app.document.head.querySelector('[data-hide-command-log-request]')) {
  const style = app.document.createElement('style');
  style.innerHTML = '.command-name-request, .command-name-xhr { display: none }';
  style.setAttribute('data-hide-command-log-request', '');
  app.document.head.appendChild(style);
}
```

Create e2e/support/index.d.ts for TypeScript declarations:
```typescript
/// <reference types="cypress" />

declare namespace Cypress {
  interface Chainable {
    // Auth commands
    login(email: string, password: string): Chainable<void>;
    loginScanner(): Chainable<void>;

    // Purchase commands
    fillStripe(): Chainable<void>;
    fillStripeDeclined(declineType: 'generic' | 'insufficientFunds' | 'expired' | 'incorrectCvc'): Chainable<void>;

    // Scan commands
    scanTicket(qrCodeToken: string): Chainable<void>;

    // DB verification (via cy.task, but type helpers)
  }
}
```

Create e2e/fixtures/stripe-cards.json:
```json
{
  "valid": {
    "number": "4242424242424242",
    "expiry": "1230",
    "cvc": "123",
    "zip": "90210"
  },
  "declined": {
    "generic": "4000000000000002",
    "insufficientFunds": "4000000000009995",
    "expired": "4000000000000069",
    "incorrectCvc": "4000000000000127"
  }
}
```
  </action>
  <verify>
Run `npx cypress open --config-file e2e/cypress.config.ts` - Cypress should open and show the e2e testing option.
Verify the e2e/support/e2e.ts file exists and imports are correct.
  </verify>
  <done>Cypress config with cross-origin support, Supabase tasks, video capture, and Stripe plugin integration complete</done>
</task>

<task type="auto">
  <name>Task 3: Create custom commands for auth, purchase, scan, and DB</name>
  <files>
    e2e/support/commands/auth.ts
    e2e/support/commands/purchase.ts
    e2e/support/commands/scan.ts
    e2e/support/commands/db.ts
  </files>
  <action>
Create e2e/support/commands/auth.ts:
```typescript
/// <reference types="cypress" />

// Login with session caching
Cypress.Commands.add('login', (email: string, password: string) => {
  cy.session([email], () => {
    cy.visit('/auth');
    cy.get('input[type="email"], input[name="email"], [data-cy="email"]').type(email);
    cy.get('input[type="password"], input[name="password"], [data-cy="password"]').type(password);
    cy.get('button[type="submit"], [data-cy="login-button"]').click();
    // Wait for redirect to dashboard or scanner
    cy.url().should('not.contain', '/auth');
  }, {
    cacheAcrossSpecs: true,
  });
});

// Login to scanner app with configured credentials
Cypress.Commands.add('loginScanner', () => {
  const email = Cypress.env('SCANNER_EMAIL');
  const password = Cypress.env('SCANNER_PASSWORD');

  cy.session(['scanner', email], () => {
    cy.visit(Cypress.env('SCANNER_URL') + '/auth');
    cy.get('input[type="email"], input[name="email"], [data-cy="email"]').type(email);
    cy.get('input[type="password"], input[name="password"], [data-cy="password"]').type(password);
    cy.get('button[type="submit"], [data-cy="login-button"]').click();
    cy.url().should('not.contain', '/auth');
  }, {
    cacheAcrossSpecs: true,
  });
});
```

Create e2e/support/commands/purchase.ts:
```typescript
/// <reference types="cypress" />
import 'cypress-plugin-stripe-elements';

// Fill Stripe payment form with valid card
Cypress.Commands.add('fillStripe', () => {
  // Wait for Stripe iframe to load
  cy.get('iframe[name^="__privateStripeFrame"]', { timeout: 15000 }).should('exist');

  // Use the plugin to fill card details
  cy.get('iframe[name^="__privateStripeFrame"]').first().within({ log: false }, () => {
    cy.fillElementsInput('cardNumber', '4242424242424242');
    cy.fillElementsInput('cardExpiry', '1230');
    cy.fillElementsInput('cardCvc', '123');
  });

  // Fill ZIP if visible (depends on Stripe config)
  cy.get('body').then(($body) => {
    if ($body.find('iframe[name*="postal"]').length > 0) {
      cy.get('iframe[name*="postal"]').within({ log: false }, () => {
        cy.fillElementsInput('postalCode', '90210');
      });
    }
  });
});

// Fill Stripe with a declined card
Cypress.Commands.add('fillStripeDeclined', (declineType: 'generic' | 'insufficientFunds' | 'expired' | 'incorrectCvc') => {
  const cards: Record<string, string> = {
    generic: '4000000000000002',
    insufficientFunds: '4000000000009995',
    expired: '4000000000000069',
    incorrectCvc: '4000000000000127',
  };

  cy.get('iframe[name^="__privateStripeFrame"]', { timeout: 15000 }).should('exist');

  cy.get('iframe[name^="__privateStripeFrame"]').first().within({ log: false }, () => {
    cy.fillElementsInput('cardNumber', cards[declineType]);
    cy.fillElementsInput('cardExpiry', '1230');
    cy.fillElementsInput('cardCvc', '123');
  });
});
```

Create e2e/support/commands/scan.ts:
```typescript
/// <reference types="cypress" />

// Scan a ticket using manual entry (simulates QR scan)
Cypress.Commands.add('scanTicket', (qrCodeToken: string) => {
  // Look for manual entry input or scan input
  cy.get('[data-cy="manual-entry"], input[placeholder*="ticket"], input[placeholder*="QR"], input[name="ticketId"]', { timeout: 10000 })
    .should('be.visible')
    .clear()
    .type(qrCodeToken);

  // Click lookup/scan button
  cy.get('[data-cy="lookup-button"], [data-cy="scan-button"], button:contains("Lookup"), button:contains("Check")').first().click();
});
```

Create e2e/support/commands/db.ts:
```typescript
/// <reference types="cypress" />

// DB verification commands are implemented as cy.task() in cypress.config.ts
// This file provides convenient wrappers and additional utilities

// Utility to wait for email to be queued (with polling)
Cypress.Commands.add('waitForEmailQueued', { prevSubject: false }, (ticketId: string, timeout = 30000) => {
  const startTime = Date.now();

  const checkEmail = (): Cypress.Chainable<any> => {
    return cy.task('verifyEmailQueued', ticketId, { log: false }).then((emails: any[]) => {
      if (emails && emails.length > 0) {
        return emails;
      }
      if (Date.now() - startTime > timeout) {
        throw new Error(`Email not queued for ticket ${ticketId} within ${timeout}ms`);
      }
      // Wait and retry
      return cy.wait(1000, { log: false }).then(() => checkEmail());
    });
  };

  return checkEmail();
});

// Extend type declarations
declare global {
  namespace Cypress {
    interface Chainable {
      waitForEmailQueued(ticketId: string, timeout?: number): Chainable<any[]>;
    }
  }
}

export {};
```
  </action>
  <verify>
Open Cypress and create a simple test file e2e/specs/smoke.cy.ts:
```typescript
describe('Smoke Test', () => {
  it('loads pass-lounge homepage', () => {
    cy.visit('/');
    cy.get('body').should('be.visible');
  });
});
```
Run `npx cypress run --config-file e2e/cypress.config.ts --spec "e2e/specs/smoke.cy.ts"` (will need apps running).
Verify no TypeScript errors in the command files.
  </verify>
  <done>Custom commands created for auth (with session caching), purchase (Stripe fill), scan (manual entry), and DB verification</done>
</task>

</tasks>

<verification>
1. `npm ls cypress` shows Cypress 15.x installed
2. `npx cypress --version` returns version number
3. e2e/ folder structure exists with all required files
4. TypeScript compiles without errors: `npx tsc --noEmit -p e2e/tsconfig.json`
5. Cypress opens successfully: `npm run cy:open`
</verification>

<success_criteria>
- Cypress 15.x installed at project root
- cypress.config.ts exists with cross-origin support and Supabase tasks
- Custom commands exist for login, purchase flow, scan, and DB verification
- TypeScript declarations provide proper typing
- Stripe test card fixtures available
- npm scripts added for opening and running Cypress
</success_criteria>

<output>
After completion, create `.planning/phases/08-ga-e2e-testing/08-01-SUMMARY.md`
</output>
