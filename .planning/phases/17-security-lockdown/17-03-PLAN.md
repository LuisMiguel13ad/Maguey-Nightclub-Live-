---
phase: 17-security-lockdown
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - maguey-pass-lounge/supabase/migrations/20260213000000_tighten_vip_rls_policies.sql
  - maguey-pass-lounge/src/pages/VIPPassView.tsx
autonomous: true

must_haves:
  truths:
    - "vip_reservations SELECT policy no longer includes auth.role() = 'anon'"
    - "vip_guest_passes SELECT policy no longer includes auth.role() = 'anon'"
    - "get_vip_pass_by_token RPC function exists with SECURITY DEFINER for public token-based lookup"
    - "VIPPassView.tsx calls get_vip_pass_by_token RPC instead of direct table query"
    - "VIPPassView still renders correctly for valid tokens without requiring authentication"
    - "event_vip_tables SELECT policy remains open (needed for public booking page)"
  artifacts:
    - path: "maguey-pass-lounge/supabase/migrations/20260213000000_tighten_vip_rls_policies.sql"
      provides: "Migration that removes anon access and creates SECURITY DEFINER RPC"
      exports: []
    - path: "maguey-pass-lounge/src/pages/VIPPassView.tsx"
      provides: "VIP pass view page using RPC instead of direct query"
      exports: ["default"]
  key_links:
    - from: "maguey-pass-lounge/src/pages/VIPPassView.tsx"
      to: "maguey-pass-lounge/supabase/migrations/20260213000000_tighten_vip_rls_policies.sql"
      via: "supabase.rpc('get_vip_pass_by_token')"
      pattern: "rpc.*get_vip_pass_by_token"
---

<objective>
Remove anonymous SELECT access from VIP reservation and guest pass RLS policies, and create a SECURITY DEFINER RPC function for the public VIP pass view page to use instead.

Purpose: This is P0 blocker R05. Currently, anonymous users can query the full `vip_reservations` and `vip_guest_passes` tables, exposing PII (purchaser names, emails, phone numbers, QR tokens). After this plan, anonymous access is blocked and the public pass view page uses a token-based RPC that returns only the specific matching record.

Output: A new Supabase migration that tightens RLS policies and creates the RPC, plus an updated VIPPassView.tsx that uses the RPC.
</objective>

<execution_context>
@/Users/luismiguel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luismiguel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/17-security-lockdown/17-RESEARCH.md
@maguey-pass-lounge/supabase/migrations/20260128100000_fix_vip_system_comprehensive.sql (lines 250-280 for current policies)
@maguey-pass-lounge/src/pages/VIPPassView.tsx
@maguey-pass-lounge/src/lib/supabase.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create migration to tighten VIP RLS policies and add RPC</name>
  <files>maguey-pass-lounge/supabase/migrations/20260213000000_tighten_vip_rls_policies.sql</files>
  <action>
Create a new migration file at `maguey-pass-lounge/supabase/migrations/20260213000000_tighten_vip_rls_policies.sql`.

**Migration contents:**

```sql
-- ============================================================================
-- Phase 17-03: Tighten VIP RLS Policies
-- ============================================================================
-- Removes anonymous SELECT access from vip_reservations and vip_guest_passes.
-- Creates SECURITY DEFINER RPC for public token-based VIP pass lookup.
--
-- BEFORE: Anonymous users could query ALL rows in both tables (PII exposure)
-- AFTER: Only authenticated users and service_role can SELECT.
--        Public pass view uses get_vip_pass_by_token() RPC (returns single record by token).
-- ============================================================================
```

**Part 1: Drop and recreate vip_reservations SELECT policy:**
```sql
-- Remove old policy that allowed anonymous access
DROP POLICY IF EXISTS "vip_reservations_select" ON vip_reservations;

-- Recreate without anon access
CREATE POLICY "vip_reservations_select" ON vip_reservations FOR SELECT
  USING (
    auth.role() = 'service_role'
    OR (auth.role() = 'authenticated' AND purchaser_email = auth.jwt() ->> 'email')
  );
```

**Part 2: Drop and recreate vip_guest_passes SELECT policy:**
```sql
-- Remove old policy that allowed anonymous access
DROP POLICY IF EXISTS "vip_guest_passes_select" ON vip_guest_passes;

-- Recreate without anon access
CREATE POLICY "vip_guest_passes_select" ON vip_guest_passes FOR SELECT
  USING (
    auth.role() = 'service_role'
    OR auth.role() = 'authenticated'
  );
```

**Part 3: Create SECURITY DEFINER RPC for token-based lookup:**
```sql
-- RPC for public VIP pass view (bypasses RLS via SECURITY DEFINER)
-- Returns only the specific pass matching the QR code token.
-- This is safe because:
-- 1. Lookup is by token (must know the exact token to get data)
-- 2. Returns limited fields (no full table scan)
-- 3. Token is a UUID, not guessable
CREATE OR REPLACE FUNCTION get_vip_pass_by_token(p_qr_token TEXT)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_result JSON;
BEGIN
  -- Validate input
  IF p_qr_token IS NULL OR p_qr_token = '' THEN
    RETURN NULL;
  END IF;

  SELECT json_build_object(
    'id', gp.id,
    'pass_number', gp.pass_number,
    'guest_name', gp.guest_name,
    'guest_email', gp.guest_email,
    'pass_type', gp.pass_type,
    'qr_token', gp.qr_code_token,
    'status', gp.status,
    'scanned_at', gp.scanned_at,
    'vip_reservations', json_build_object(
      'id', vr.id,
      'table_number', vr.table_number,
      'purchaser_name', vr.purchaser_name,
      'package_snapshot', vr.package_snapshot,
      'event_vip_tables', CASE
        WHEN evt.id IS NOT NULL THEN json_build_object(
          'table_number', evt.table_number,
          'tier', evt.tier,
          'guest_capacity', evt.guest_capacity
        )
        ELSE NULL
      END,
      'events', CASE
        WHEN e.id IS NOT NULL THEN json_build_object(
          'id', e.id,
          'name', e.name,
          'event_date', e.event_date,
          'venue_name', e.venue_name,
          'image_url', e.image_url
        )
        ELSE NULL
      END
    )
  )
  INTO v_result
  FROM vip_guest_passes gp
  JOIN vip_reservations vr ON gp.vip_reservation_id = vr.id
  LEFT JOIN events e ON vr.event_id = e.id
  LEFT JOIN event_vip_tables evt ON vr.table_id = evt.id
  WHERE gp.qr_code_token = p_qr_token;

  RETURN v_result;
END;
$$;
```

**Important notes on the RPC:**
- The JSON structure matches what VIPPassView.tsx expects: `passData` with nested `vip_reservations` containing `events` and `event_vip_tables`.
- Uses `LEFT JOIN` for events and event_vip_tables since they may be null.
- The join for `event_vip_tables` uses `vr.table_id = evt.id` (the foreign key from vip_reservations to event_vip_tables). Verify this column exists. If the FK column is named differently (e.g., `vr.event_vip_table_id`), adjust accordingly.
- `SET search_path = public` is a security best practice for SECURITY DEFINER functions.

**Part 4: Note about event_vip_tables:**
The `event_vip_tables` SELECT policy uses `USING (true)` which allows everyone (including anon). This is intentional because the public booking page needs to display available tables. Do NOT change this policy.
  </action>
  <verify>
```bash
# Verify migration file exists
ls -la maguey-pass-lounge/supabase/migrations/20260213000000_tighten_vip_rls_policies.sql

# Verify it removes anon access
grep "anon" maguey-pass-lounge/supabase/migrations/20260213000000_tighten_vip_rls_policies.sql
# Should NOT find auth.role() = 'anon' in CREATE POLICY statements

# Verify SECURITY DEFINER RPC exists
grep "SECURITY DEFINER" maguey-pass-lounge/supabase/migrations/20260213000000_tighten_vip_rls_policies.sql
grep "get_vip_pass_by_token" maguey-pass-lounge/supabase/migrations/20260213000000_tighten_vip_rls_policies.sql
```
  </verify>
  <done>
Migration file created with: vip_reservations SELECT policy without anon, vip_guest_passes SELECT policy without anon, get_vip_pass_by_token SECURITY DEFINER RPC with token-based lookup returning nested JSON matching VIPPassView expectations.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update VIPPassView.tsx to use RPC instead of direct query</name>
  <files>maguey-pass-lounge/src/pages/VIPPassView.tsx</files>
  <action>
Modify `maguey-pass-lounge/src/pages/VIPPassView.tsx` to call the `get_vip_pass_by_token` RPC instead of directly querying `vip_guest_passes`.

**Replace the `loadPass` function's query** (lines 60-71):

**Before:**
```typescript
const { data: passData, error: passError } = await supabase
  .from('vip_guest_passes')
  .select(`
    *,
    vip_reservations (
      *,
      events (*),
      event_vip_tables (*)
    )
  `)
  .eq('qr_code_token', token)
  .single();
```

**After:**
```typescript
const { data: passData, error: passError } = await supabase
  .rpc('get_vip_pass_by_token', { p_qr_token: token });
```

**Important:** The RPC returns a JSON object with the same nested structure as the previous `.select()` query. The fields map as follows:
- `passData.id` -> `passData.id`
- `passData.pass_number` -> `passData.pass_number`
- `passData.guest_name` -> `passData.guest_name`
- `passData.guest_email` -> `passData.guest_email`
- `passData.pass_type` -> `passData.pass_type`
- `passData.qr_token` -> `passData.qr_token` (mapped from `qr_code_token` in RPC)
- `passData.status` -> `passData.status`
- `passData.scanned_at` -> `passData.scanned_at`
- `passData.vip_reservations` -> `passData.vip_reservations` (nested object, same as before)

**Update the `PassData` interface** — the `qr_token` field name may need adjustment. The RPC returns it as `qr_token` (matching the current interface), mapped from the database column `qr_code_token`. If the existing interface uses `qr_token`, no change needed.

**Update the error check** — The RPC returns `null` when no pass is found (not an error):
```typescript
if (passError || !passData) {
  setError('Pass not found');
  setLoading(false);
  return;
}
```
This check works the same as before since the RPC returns null for no match and errors propagate through passError.

**No other changes needed** — The rest of the component (setPass, setReservation, rendering) continues to work because the JSON structure matches.
  </action>
  <verify>
```bash
# Verify RPC call is used
grep "rpc.*get_vip_pass_by_token" maguey-pass-lounge/src/pages/VIPPassView.tsx

# Verify direct table query is removed
grep "from.*vip_guest_passes" maguey-pass-lounge/src/pages/VIPPassView.tsx
# Should return nothing

# TypeScript compile check
cd maguey-pass-lounge && npx tsc --noEmit src/pages/VIPPassView.tsx 2>&1 | head -10
```
  </verify>
  <done>
VIPPassView.tsx uses get_vip_pass_by_token RPC for data fetching. Direct vip_guest_passes query removed. Component rendering unchanged since JSON structure matches.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Migration file exists and is correct:**
   - No `auth.role() = 'anon'` in CREATE POLICY statements
   - SECURITY DEFINER RPC `get_vip_pass_by_token` defined
   - `event_vip_tables` policy NOT modified (intentionally left open)

2. **VIPPassView uses RPC:**
   ```bash
   grep "rpc" maguey-pass-lounge/src/pages/VIPPassView.tsx
   grep "from.*vip_guest_passes" maguey-pass-lounge/src/pages/VIPPassView.tsx
   ```
   First should match, second should not.

3. **TypeScript compiles:**
   ```bash
   cd maguey-pass-lounge && npx tsc --noEmit 2>&1 | grep -i error | head -10
   ```

4. **Manual verification note:** After applying the migration to Supabase:
   - Test VIPPassView with a valid token (should work via RPC)
   - Test VIPPassView with invalid token (should show "Pass not found")
   - Verify that `supabase.from('vip_reservations').select('*')` as anonymous user returns empty (blocked by RLS)
</verification>

<success_criteria>
- Migration removes anon access from vip_reservations and vip_guest_passes SELECT policies
- SECURITY DEFINER RPC get_vip_pass_by_token created with token-based lookup
- VIPPassView.tsx calls RPC instead of direct table query
- event_vip_tables policy unchanged (still allows public access for booking page)
- TypeScript compilation succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/17-security-lockdown/17-03-SUMMARY.md`
</output>
