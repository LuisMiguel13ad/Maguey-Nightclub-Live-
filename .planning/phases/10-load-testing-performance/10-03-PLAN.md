---
phase: 10-load-testing-performance
plan: 03
type: execute
wave: 2
depends_on: [10-01]
files_modified:
  - load-tests/scenarios/scanner-burst.js
  - load-tests/data/test-tickets.json
autonomous: true

must_haves:
  truths:
    - "10 simultaneous scan requests complete without errors"
    - "p95 response time stays under 200ms (scanner must be fast)"
    - "Race condition handling works under concurrent load"
    - "Already-scanned tickets return correct rejection"
  artifacts:
    - path: "load-tests/scenarios/scanner-burst.js"
      provides: "k6 load test for 10 simultaneous scans"
      min_lines: 100
    - path: "load-tests/data/test-tickets.json"
      provides: "Sample ticket IDs for load testing"
  key_links:
    - from: "load-tests/scenarios/scanner-burst.js"
      to: "/rest/v1/rpc/scan_ticket_atomic"
      via: "http.post"
      pattern: "scan_ticket_atomic"
    - from: "load-tests/scenarios/scanner-burst.js"
      to: "load-tests/config/thresholds.js"
      via: "import"
      pattern: "getThresholds.*scanner"
---

<objective>
Create k6 load test for 10 simultaneous scanner operations against the scan_ticket_atomic RPC.

Purpose: Validate success criteria #2 - "Scanner handles 10 simultaneous scans at gate without lag". Gate scanning is time-critical for event entry flow and must remain responsive under burst load.

Output: `load-tests/scenarios/scanner-burst.js` - executable k6 test with race condition scenarios.
</objective>

<execution_context>
@/Users/luismiguel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luismiguel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/10-load-testing-performance/10-CONTEXT.md
@.planning/phases/10-load-testing-performance/10-RESEARCH.md
@maguey-pass-lounge/supabase/migrations/20260130200000_add_scan_race_condition_handling.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create scanner burst load test</name>
  <files>load-tests/scenarios/scanner-burst.js</files>
  <action>
Create k6 load test script that validates 10 simultaneous scanner operations.

Key test scenarios:
1. **Unique ticket scans** - 10 VUs scanning different tickets simultaneously
2. **Race condition test** - 10 VUs attempting to scan the SAME ticket

```javascript
// Scanner Burst Load Test - 10 Simultaneous Scans
// Tests: POST /rest/v1/rpc/scan_ticket_atomic
// Target: p95 < 200ms, near-zero errors

import http from 'k6/http';
import { check, sleep } from 'k6';
import { Rate, Trend, Counter } from 'k6/metrics';
import { SharedArray } from 'k6/data';
import { getThresholds } from '../config/thresholds.js';
import { getServiceHeaders, getBaseUrl } from '../helpers/auth.js';

// Custom metrics
const errorRate = new Rate('scan_errors');
const scanDuration = new Trend('scan_duration');
const successfulScans = new Counter('successful_scans');
const alreadyScannedCount = new Counter('already_scanned');
const raceConditionsCaught = new Counter('race_conditions_caught');

// Test ticket data (will be populated by setup or SharedArray)
const testTickets = new SharedArray('tickets', function() {
  // Try to load from file, fall back to generated UUIDs
  try {
    return JSON.parse(open('../data/test-tickets.json')).tickets;
  } catch {
    // Generate test UUIDs if file doesn't exist
    return Array.from({ length: 100 }, (_, i) => ({
      id: `00000000-0000-0000-0000-${String(i).padStart(12, '0')}`,
      event_id: __ENV.TEST_EVENT_ID || 'test-event-id',
    }));
  }
});

export const options = {
  scenarios: {
    // Scenario 1: Unique ticket scans (10 VUs, different tickets)
    scanner_burst: {
      executor: 'constant-vus',
      vus: 10,
      duration: '1m',
      exec: 'uniqueTicketScans',
    },
    // Scenario 2: Race condition test (10 VUs, same ticket)
    race_condition: {
      executor: 'per-vu-iterations',
      vus: 10,
      iterations: 1,  // Each VU tries once
      startTime: '1m10s',  // Start after burst test
      exec: 'raceConditionTest',
    },
  },
  thresholds: {
    ...getThresholds('scanner'),
    'scan_duration': ['p(95)<200'],
    'scan_errors': ['rate<0.001'],  // Near-zero errors for scanner
  },
};

// Scenario 1: Each VU scans different tickets
export function uniqueTicketScans() {
  const baseUrl = getBaseUrl();
  const headers = getServiceHeaders();

  // Each VU gets a different ticket based on VU ID and iteration
  const ticketIndex = (__VU - 1 + __ITER * 10) % testTickets.length;
  const ticket = testTickets[ticketIndex];

  const payload = JSON.stringify({
    p_ticket_id: ticket.id,
    p_scanned_by: __ENV.TEST_SCANNER_ID || '00000000-0000-0000-0000-000000000001',
    p_device_id: `loadtest_scanner_${__VU}`,
    p_scan_method: 'qr',
  });

  const startTime = Date.now();

  const response = http.post(
    `${baseUrl}/rest/v1/rpc/scan_ticket_atomic`,
    payload,
    { headers, timeout: '10s' }
  );

  const duration = Date.now() - startTime;
  scanDuration.add(duration);

  const success = check(response, {
    'status is 200': (r) => r.status === 200,
    'has response body': (r) => r.body && r.body.length > 0,
    'response under 200ms': () => duration < 200,
  });

  // Parse response to track scan outcomes
  try {
    const result = JSON.parse(response.body);
    if (Array.isArray(result) && result.length > 0) {
      const scanResult = result[0];
      if (scanResult.success) {
        successfulScans.add(1);
      } else if (scanResult.already_scanned) {
        alreadyScannedCount.add(1);
      }
    }
  } catch {
    // Ignore parse errors
  }

  errorRate.add(!success);

  if (!success) {
    console.log(`[VU ${__VU}] Scan failed: ${response.status} - ${response.body?.substring(0, 100)}`);
  }

  // Minimal delay between scans (simulating rapid gate entry)
  sleep(0.1);
}

// Scenario 2: Test race condition handling
export function raceConditionTest() {
  const baseUrl = getBaseUrl();
  const headers = getServiceHeaders();

  // ALL VUs try to scan the SAME ticket simultaneously
  const sharedTicketId = __ENV.RACE_TEST_TICKET_ID || '00000000-0000-0000-0000-000000000099';

  const payload = JSON.stringify({
    p_ticket_id: sharedTicketId,
    p_scanned_by: __ENV.TEST_SCANNER_ID || '00000000-0000-0000-0000-000000000001',
    p_device_id: `loadtest_race_${__VU}`,
    p_scan_method: 'qr',
  });

  const startTime = Date.now();

  const response = http.post(
    `${baseUrl}/rest/v1/rpc/scan_ticket_atomic`,
    payload,
    { headers, timeout: '10s' }
  );

  const duration = Date.now() - startTime;

  const success = check(response, {
    'race test returns 200': (r) => r.status === 200,
    'response is valid JSON': (r) => {
      try {
        JSON.parse(r.body);
        return true;
      } catch {
        return false;
      }
    },
  });

  // Count race condition outcomes
  try {
    const result = JSON.parse(response.body);
    if (Array.isArray(result) && result.length > 0) {
      const scanResult = result[0];
      if (scanResult.success) {
        console.log(`[VU ${__VU}] WON the race - successful scan in ${duration}ms`);
      } else if (scanResult.already_scanned || scanResult.error_message?.includes('Concurrent')) {
        raceConditionsCaught.add(1);
        console.log(`[VU ${__VU}] Lost race - ${scanResult.error_message} (${duration}ms)`);
      }
    }
  } catch {
    // Ignore parse errors
  }

  if (!success) {
    console.log(`[VU ${__VU}] Race test error: ${response.status}`);
  }
}

// Summary report
export function handleSummary(data) {
  const metrics = data.metrics;
  const thresholdResults = Object.entries(data.thresholds || {})
    .map(([name, result]) => `  ${result.ok ? 'PASS' : 'FAIL'} ${name}`)
    .join('\n');

  const summary = `
================================================================================
                      SCANNER BURST LOAD TEST RESULTS
================================================================================

Configuration:
  Scenario 1:     10 VUs scanning unique tickets for 1 minute
  Scenario 2:     10 VUs racing to scan same ticket
  Endpoint:       POST /rest/v1/rpc/scan_ticket_atomic

Scan Results:
  Total Requests: ${metrics.http_reqs?.values?.count || 0}
  Successful:     ${metrics.successful_scans?.values?.count || 0}
  Already Scanned: ${metrics.already_scanned?.values?.count || 0}
  Error Rate:     ${((metrics.scan_errors?.values?.rate || 0) * 100).toFixed(3)}%

Response Times:
  Average:        ${Math.round(metrics.scan_duration?.values?.avg || 0)}ms
  P95:            ${Math.round(metrics.scan_duration?.values?.['p(95)'] || 0)}ms
  P99:            ${Math.round(metrics.scan_duration?.values?.['p(99)'] || 0)}ms
  Max:            ${Math.round(metrics.scan_duration?.values?.max || 0)}ms

Race Condition Handling:
  Concurrent attempts caught: ${metrics.race_conditions_caught?.values?.count || 0}
  (Expected: 9 out of 10 VUs should be blocked)

Thresholds:
${thresholdResults}

================================================================================
`;

  return {
    'stdout': summary,
    'load-tests/results/scanner-burst-results.json': JSON.stringify(data, null, 2),
  };
}
```
  </action>
  <verify>k6 run --dry-run load-tests/scenarios/scanner-burst.js validates syntax</verify>
  <done>Scanner burst test with unique scans and race condition scenarios created</done>
</task>

<task type="auto">
  <name>Task 2: Create test tickets data file</name>
  <files>load-tests/data/test-tickets.json</files>
  <action>
Create sample test ticket data for scanner load tests.

Note: These are placeholder UUIDs. Before running load tests, users should:
1. Create actual test tickets in staging environment
2. Update this file with real ticket IDs

```json
{
  "description": "Test ticket IDs for scanner load tests. Replace with real staging ticket IDs before testing.",
  "tickets": [
    { "id": "00000000-0000-0000-0001-000000000001", "event_id": "test-event-id", "type": "ga" },
    { "id": "00000000-0000-0000-0001-000000000002", "event_id": "test-event-id", "type": "ga" },
    { "id": "00000000-0000-0000-0001-000000000003", "event_id": "test-event-id", "type": "ga" },
    { "id": "00000000-0000-0000-0001-000000000004", "event_id": "test-event-id", "type": "ga" },
    { "id": "00000000-0000-0000-0001-000000000005", "event_id": "test-event-id", "type": "ga" },
    { "id": "00000000-0000-0000-0001-000000000006", "event_id": "test-event-id", "type": "ga" },
    { "id": "00000000-0000-0000-0001-000000000007", "event_id": "test-event-id", "type": "ga" },
    { "id": "00000000-0000-0000-0001-000000000008", "event_id": "test-event-id", "type": "ga" },
    { "id": "00000000-0000-0000-0001-000000000009", "event_id": "test-event-id", "type": "ga" },
    { "id": "00000000-0000-0000-0001-000000000010", "event_id": "test-event-id", "type": "ga" },
    { "id": "00000000-0000-0000-0001-000000000011", "event_id": "test-event-id", "type": "vip" },
    { "id": "00000000-0000-0000-0001-000000000012", "event_id": "test-event-id", "type": "vip" },
    { "id": "00000000-0000-0000-0001-000000000013", "event_id": "test-event-id", "type": "vip" },
    { "id": "00000000-0000-0000-0001-000000000014", "event_id": "test-event-id", "type": "vip" },
    { "id": "00000000-0000-0000-0001-000000000015", "event_id": "test-event-id", "type": "vip" }
  ],
  "raceTestTicket": {
    "id": "00000000-0000-0000-0001-000000000099",
    "description": "Dedicated ticket for race condition testing"
  },
  "setup_instructions": [
    "1. Create test event in staging Supabase",
    "2. Purchase 15+ test tickets using Stripe test mode",
    "3. Replace placeholder UUIDs with actual ticket IDs",
    "4. Set TEST_EVENT_ID environment variable",
    "5. Set RACE_TEST_TICKET_ID for race condition test"
  ]
}
```
  </action>
  <verify>cat load-tests/data/test-tickets.json | head -20</verify>
  <done>Test tickets data file created with placeholder IDs and setup instructions</done>
</task>

</tasks>

<verification>
- [ ] `load-tests/scenarios/scanner-burst.js` exists and is valid JavaScript
- [ ] Script has two scenarios: unique scans and race condition test
- [ ] Thresholds include p95 < 200ms (stricter than other tests)
- [ ] Race condition scenario tests 10 VUs on same ticket
- [ ] `load-tests/data/test-tickets.json` exists with sample data
- [ ] Metrics track successful scans, already-scanned, and race conditions caught
</verification>

<success_criteria>
- k6 test validates 10 simultaneous scan operations
- p95 threshold set to 200ms (scanner must be fast)
- Race condition handling tested explicitly
- Metrics distinguish between successful scans and race condition rejections
- Test data file created with setup instructions
</success_criteria>

<output>
After completion, create `.planning/phases/10-load-testing-performance/10-03-SUMMARY.md`
</output>
