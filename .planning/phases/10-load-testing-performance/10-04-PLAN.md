---
phase: 10-load-testing-performance
plan: 04
type: execute
wave: 2
depends_on: [10-01]
files_modified:
  - load-tests/scenarios/dashboard-load.js
autonomous: true

must_haves:
  truths:
    - "Dashboard data loads within 3 seconds under 20 concurrent viewers"
    - "Parallel API requests for events, tickets, and orders complete successfully"
    - "Real-time subscription connections can be established"
    - "Error rate remains below 1%"
  artifacts:
    - path: "load-tests/scenarios/dashboard-load.js"
      provides: "k6 load test for dashboard performance"
      min_lines: 100
  key_links:
    - from: "load-tests/scenarios/dashboard-load.js"
      to: "/rest/v1/events"
      via: "http.batch"
      pattern: "rest/v1/events"
    - from: "load-tests/scenarios/dashboard-load.js"
      to: "/rest/v1/tickets"
      via: "http.batch"
      pattern: "rest/v1/tickets"
---

<objective>
Create k6 load test for dashboard performance under 20 concurrent viewers.

Purpose: Validate success criteria #3 - "Dashboard loads within 3 seconds under normal traffic". The owner dashboard aggregates data from multiple sources (events, tickets, orders, revenue) and must remain responsive.

Output: `load-tests/scenarios/dashboard-load.js` - executable k6 test with parallel API calls.
</objective>

<execution_context>
@/Users/luismiguel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luismiguel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/10-load-testing-performance/10-CONTEXT.md
@.planning/phases/10-load-testing-performance/10-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create dashboard load test</name>
  <files>load-tests/scenarios/dashboard-load.js</files>
  <action>
Create k6 load test script that validates dashboard performance under 20 concurrent viewers.

Test simulates dashboard data loading pattern:
1. Fetch events list
2. Fetch ticket counts for events
3. Fetch order/revenue data
4. Simulate periodic refresh (5s interval)

Use http.batch() for parallel requests (matching real dashboard behavior).

```javascript
// Dashboard Load Test - 20 Concurrent Viewers
// Tests: Multiple REST API endpoints in parallel
// Target: Initial load < 3s, error rate < 1%

import http from 'k6/http';
import { check, sleep, group } from 'k6';
import { Rate, Trend, Counter } from 'k6/metrics';
import { getThresholds } from '../config/thresholds.js';
import { getServiceHeaders, getBaseUrl } from '../helpers/auth.js';

// Custom metrics
const errorRate = new Rate('dashboard_errors');
const initialLoadDuration = new Trend('initial_load_duration');
const refreshDuration = new Trend('refresh_duration');
const apiCallCount = new Counter('api_calls');

export const options = {
  scenarios: {
    dashboard_viewers: {
      executor: 'constant-vus',
      vus: 20,
      duration: '3m',
    },
  },
  thresholds: {
    ...getThresholds('dashboard'),
    'initial_load_duration': ['p(95)<3000'],  // Dashboard < 3s
    'refresh_duration': ['p(95)<1000'],        // Refresh < 1s
    'dashboard_errors': ['rate<0.01'],
  },
};

export default function() {
  const baseUrl = getBaseUrl();
  const headers = getServiceHeaders();
  const eventId = __ENV.TEST_EVENT_ID || 'test-event-id';

  // Group 1: Initial dashboard load (parallel requests)
  group('initial_load', function() {
    const startTime = Date.now();

    // Simulate dashboard initial load with parallel API calls
    const responses = http.batch([
      // Events list
      {
        method: 'GET',
        url: `${baseUrl}/rest/v1/events?select=*&order=date.desc&limit=10`,
        params: { headers },
      },
      // Ticket counts (aggregated)
      {
        method: 'GET',
        url: `${baseUrl}/rest/v1/tickets?select=id,event_id,status&event_id=eq.${eventId}`,
        params: { headers },
      },
      // Orders with revenue
      {
        method: 'GET',
        url: `${baseUrl}/rest/v1/orders?select=id,total_amount,status,created_at&event_id=eq.${eventId}&status=eq.paid&limit=100`,
        params: { headers },
      },
      // VIP reservations
      {
        method: 'GET',
        url: `${baseUrl}/rest/v1/vip_reservations?select=id,status,total_price&event_id=eq.${eventId}`,
        params: { headers },
      },
    ]);

    const duration = Date.now() - startTime;
    initialLoadDuration.add(duration);
    apiCallCount.add(responses.length);

    // Validate all responses
    let allSuccess = true;
    responses.forEach((response, index) => {
      const endpoints = ['events', 'tickets', 'orders', 'vip_reservations'];
      const success = check(response, {
        [`${endpoints[index]} status 200`]: (r) => r.status === 200,
        [`${endpoints[index]} has body`]: (r) => r.body && r.body.length > 0,
      });
      if (!success) allSuccess = false;
    });

    check(null, {
      'initial load under 3s': () => duration < 3000,
      'initial load under 5s': () => duration < 5000,
    });

    errorRate.add(!allSuccess);

    if (!allSuccess) {
      console.log(`[VU ${__VU}] Initial load failed (${duration}ms)`);
      responses.forEach((r, i) => {
        if (r.status !== 200) {
          console.log(`  - Request ${i}: ${r.status}`);
        }
      });
    }
  });

  // Simulate user viewing dashboard for 5 seconds
  sleep(5);

  // Group 2: Dashboard refresh (lighter request)
  group('refresh', function() {
    const startTime = Date.now();

    // Refresh typically fetches updated counts
    const responses = http.batch([
      {
        method: 'GET',
        url: `${baseUrl}/rest/v1/tickets?select=count&event_id=eq.${eventId}`,
        params: { headers },
      },
      {
        method: 'GET',
        url: `${baseUrl}/rest/v1/scan_logs?select=count&event_id=eq.${eventId}`,
        params: { headers },
      },
    ]);

    const duration = Date.now() - startTime;
    refreshDuration.add(duration);
    apiCallCount.add(responses.length);

    const success = check(responses[0], {
      'refresh status 200': (r) => r.status === 200,
    });

    check(null, {
      'refresh under 1s': () => duration < 1000,
    });

    errorRate.add(!success);
  });

  // Wait before next iteration (simulating user viewing)
  sleep(Math.random() * 3 + 2);
}

// Summary report
export function handleSummary(data) {
  const metrics = data.metrics;
  const thresholdResults = Object.entries(data.thresholds || {})
    .map(([name, result]) => `  ${result.ok ? 'PASS' : 'FAIL'} ${name}`)
    .join('\n');

  const summary = `
================================================================================
                     DASHBOARD LOAD TEST RESULTS
================================================================================

Configuration:
  Concurrent Viewers: 20 VUs
  Duration:          3 minutes
  Endpoints:         events, tickets, orders, vip_reservations, scan_logs

Load Performance:
  Total API Calls:   ${metrics.api_calls?.values?.count || 0}
  Error Rate:        ${((metrics.dashboard_errors?.values?.rate || 0) * 100).toFixed(2)}%

Initial Load Times:
  Average:           ${Math.round(metrics.initial_load_duration?.values?.avg || 0)}ms
  P95:               ${Math.round(metrics.initial_load_duration?.values?.['p(95)'] || 0)}ms
  P99:               ${Math.round(metrics.initial_load_duration?.values?.['p(99)'] || 0)}ms
  Max:               ${Math.round(metrics.initial_load_duration?.values?.max || 0)}ms

Refresh Times:
  Average:           ${Math.round(metrics.refresh_duration?.values?.avg || 0)}ms
  P95:               ${Math.round(metrics.refresh_duration?.values?.['p(95)'] || 0)}ms
  Max:               ${Math.round(metrics.refresh_duration?.values?.max || 0)}ms

Thresholds:
${thresholdResults}

================================================================================
`;

  return {
    'stdout': summary,
    'load-tests/results/dashboard-load-results.json': JSON.stringify(data, null, 2),
  };
}
```

Key features:
- Uses http.batch() for parallel API calls (mimics real dashboard)
- Two test groups: initial_load and refresh
- Initial load threshold: p95 < 3s per success criteria
- Refresh threshold: p95 < 1s (incremental updates should be fast)
- Simulates realistic user behavior with 5s view time between refreshes
  </action>
  <verify>k6 run --dry-run load-tests/scenarios/dashboard-load.js validates syntax</verify>
  <done>Dashboard load test with parallel API calls and 3s threshold created</done>
</task>

</tasks>

<verification>
- [ ] `load-tests/scenarios/dashboard-load.js` exists and is valid JavaScript
- [ ] Script uses http.batch() for parallel requests
- [ ] Two groups: initial_load and refresh with separate metrics
- [ ] Initial load threshold is p95 < 3000ms
- [ ] 20 VUs configured for 3 minute duration
- [ ] Summary shows both initial and refresh timing metrics
</verification>

<success_criteria>
- k6 test validates dashboard performance under 20 concurrent viewers
- Initial load p95 threshold set to 3 seconds per CONTEXT.md
- Parallel API calls simulate real dashboard behavior
- Refresh interval simulates realistic user viewing pattern
- Metrics distinguish initial load from refresh performance
</success_criteria>

<output>
After completion, create `.planning/phases/10-load-testing-performance/10-04-SUMMARY.md`
</output>
