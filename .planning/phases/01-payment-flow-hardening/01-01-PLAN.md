---
phase: 01-payment-flow-hardening
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - maguey-pass-lounge/supabase/migrations/20260130000000_add_payment_constraints_and_failures.sql
autonomous: true

must_haves:
  truths:
    - "Duplicate webhook processing cannot create duplicate tickets"
    - "Duplicate webhook processing cannot create duplicate VIP reservations"
    - "Failed payments are tracked and visible to owner"
  artifacts:
    - path: "maguey-pass-lounge/supabase/migrations/20260130000000_add_payment_constraints_and_failures.sql"
      provides: "Database constraints and payment_failures table"
      contains: "UNIQUE.*stripe_payment_intent_id"
  key_links:
    - from: "tickets table"
      to: "stripe_payment_intent_id column"
      via: "unique constraint"
      pattern: "unique_ticket_stripe_payment"
    - from: "vip_reservations table"
      to: "stripe_payment_intent_id column"
      via: "unique constraint"
      pattern: "unique_vip_stripe_payment"
---

<objective>
Add database-level protection against duplicate payments and create infrastructure for tracking payment failures.

Purpose: Database constraints are the last line of defense against duplicate charges. Even if webhook idempotency fails, unique constraints will reject duplicate inserts. The payment_failures table enables owner visibility into issues.

Output: Migration file with unique constraints on Stripe payment IDs and payment_failures table.
</objective>

<execution_context>
@/Users/luismiguel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luismiguel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-payment-flow-hardening/01-CONTEXT.md
@.planning/phases/01-payment-flow-hardening/01-RESEARCH.md
@maguey-pass-lounge/supabase/migrations/20250325000000_add_webhook_idempotency.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create migration for database constraints and payment_failures table</name>
  <files>maguey-pass-lounge/supabase/migrations/20260130000000_add_payment_constraints_and_failures.sql</files>
  <action>
Create a new SQL migration that:

1. Add unique constraint on `tickets.stripe_payment_intent_id` (if column exists, otherwise on stripe_session_id):
   - Check existing schema first to determine correct column
   - Use `IF NOT EXISTS` pattern for idempotency
   - Constraint name: `unique_ticket_stripe_payment`

2. Add unique constraint on `vip_reservations.stripe_payment_intent_id`:
   - Constraint name: `unique_vip_stripe_payment`
   - Handle NULL values correctly (NULLs should not conflict)

3. Add unique constraint on `orders.stripe_session_id`:
   - Constraint name: `unique_order_stripe_session`

4. Create `payment_failures` table for owner notification:
   ```sql
   CREATE TABLE IF NOT EXISTS payment_failures (
     id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
     stripe_event_id TEXT,
     stripe_payment_intent_id TEXT,
     customer_email TEXT,
     amount_cents INTEGER,
     error_message TEXT NOT NULL,
     error_code TEXT,
     payment_type TEXT NOT NULL CHECK (payment_type IN ('ga_ticket', 'vip_reservation')),
     event_id UUID REFERENCES events(id),
     resolved BOOLEAN DEFAULT FALSE,
     resolved_at TIMESTAMPTZ,
     resolved_by UUID REFERENCES auth.users(id),
     metadata JSONB DEFAULT '{}'::JSONB,
     created_at TIMESTAMPTZ DEFAULT NOW()
   );
   ```

5. Add indexes for payment_failures:
   - Index on `resolved` for filtering unresolved
   - Index on `created_at` for ordering
   - Index on `event_id` for filtering by event

6. Grant permissions:
   - Service role: SELECT, INSERT, UPDATE
   - Authenticated (owner): SELECT, UPDATE (for marking resolved)

7. Update idempotency cleanup to use 30-day retention (per user decision):
   - Modify `cleanup_expired_webhook_idempotency()` or create new function
   - Current default is 7 days, user wants 30 days
  </action>
  <verify>
Run migration locally:
```bash
cd maguey-pass-lounge && npx supabase db reset
```
Verify constraints exist:
```sql
SELECT constraint_name FROM information_schema.table_constraints
WHERE table_name IN ('tickets', 'vip_reservations', 'orders')
AND constraint_type = 'UNIQUE';
```
  </verify>
  <done>
- Unique constraints exist on stripe payment IDs
- payment_failures table exists with correct schema
- Idempotency cleanup uses 30-day retention
- Migration runs without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify constraints prevent duplicates</name>
  <files>maguey-pass-lounge/supabase/migrations/20260130000000_add_payment_constraints_and_failures.sql</files>
  <action>
Add verification queries at the end of the migration (in a DO block) to confirm:

1. Constraints are active by attempting a test insert/insert that should fail
2. payment_failures table accepts valid inserts
3. Proper RLS policies exist for payment_failures (owners can read/update)

Add RLS policies for payment_failures:
```sql
ALTER TABLE payment_failures ENABLE ROW LEVEL SECURITY;

-- Owners can view all payment failures
CREATE POLICY "owners_view_payment_failures" ON payment_failures
  FOR SELECT TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM owner_assignments oa
      WHERE oa.user_id = auth.uid()
      AND oa.role IN ('owner', 'admin')
    )
  );

-- Owners can update (mark resolved)
CREATE POLICY "owners_update_payment_failures" ON payment_failures
  FOR UPDATE TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM owner_assignments oa
      WHERE oa.user_id = auth.uid()
      AND oa.role IN ('owner', 'admin')
    )
  );

-- Service role can insert
CREATE POLICY "service_insert_payment_failures" ON payment_failures
  FOR INSERT TO service_role
  WITH CHECK (true);
```

Note: Check if `owner_assignments` table exists. If not, use alternative auth check or create simpler policy.
  </action>
  <verify>
Verify RLS policies:
```sql
SELECT * FROM pg_policies WHERE tablename = 'payment_failures';
```
  </verify>
  <done>
- RLS policies enable owner access to payment_failures
- Service role can insert failure records
- Constraints block duplicate payments
  </done>
</task>

</tasks>

<verification>
1. Run `npx supabase db reset` in maguey-pass-lounge - no errors
2. Query information_schema to confirm unique constraints exist
3. Query pg_policies to confirm RLS on payment_failures
4. Attempt duplicate insert on tickets with same stripe ID - should fail
</verification>

<success_criteria>
- Database has unique constraints on stripe_payment_intent_id / stripe_session_id columns
- payment_failures table exists and is accessible to owners
- Idempotency records expire after 30 days
- All changes are in a single, atomic migration
</success_criteria>

<output>
After completion, create `.planning/phases/01-payment-flow-hardening/01-01-SUMMARY.md`
</output>
