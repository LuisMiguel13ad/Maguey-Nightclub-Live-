---
phase: 01-payment-flow-hardening
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - maguey-pass-lounge/supabase/functions/stripe-webhook/index.ts
autonomous: true

must_haves:
  truths:
    - "Webhook processes duplicate Stripe events without creating duplicate tickets"
    - "Webhook processes duplicate Stripe events without creating duplicate VIP reservations"
    - "Webhook returns 200 immediately for duplicate events (silent skip)"
  artifacts:
    - path: "maguey-pass-lounge/supabase/functions/stripe-webhook/index.ts"
      provides: "Idempotent webhook processing"
      contains: "check_webhook_idempotency"
  key_links:
    - from: "stripe-webhook/index.ts"
      to: "webhook_idempotency table"
      via: "RPC call to check_webhook_idempotency"
      pattern: "rpc\\('check_webhook_idempotency'"
    - from: "stripe-webhook/index.ts"
      to: "webhook_idempotency table"
      via: "RPC call to update_webhook_idempotency"
      pattern: "rpc\\('update_webhook_idempotency'"
---

<objective>
Wire up the existing webhook idempotency infrastructure to prevent duplicate ticket/reservation creation.

Purpose: The `webhook_idempotency` table and RPC functions already exist but are not called by the webhook handler. This plan connects them to enable duplicate detection and silent skipping (return 200, no action).

Output: Updated stripe-webhook/index.ts that checks idempotency before processing and records processed events.
</objective>

<execution_context>
@/Users/luismiguel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luismiguel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-payment-flow-hardening/01-CONTEXT.md
@.planning/phases/01-payment-flow-hardening/01-RESEARCH.md
@maguey-pass-lounge/supabase/migrations/20250325000000_add_webhook_idempotency.sql
@maguey-pass-lounge/supabase/functions/stripe-webhook/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add idempotency check at webhook entry point</name>
  <files>maguey-pass-lounge/supabase/functions/stripe-webhook/index.ts</files>
  <action>
Modify the webhook handler to check idempotency BEFORE processing:

1. At the start of the serve() handler, after parsing the request body:
   ```typescript
   // Parse event first to get event ID
   const body = await req.text();
   const event = JSON.parse(body);
   const eventId = event.id;

   // Check idempotency BEFORE signature verification
   // This prevents replay attacks and reduces processing load
   const { data: idempotencyCheck, error: idempotencyError } = await supabase
     .rpc('check_webhook_idempotency', {
       p_idempotency_key: eventId,
       p_webhook_type: 'stripe'
     })
     .single();

   if (idempotencyError) {
     console.error('Idempotency check failed:', idempotencyError);
     // Continue processing if idempotency check fails (fail-open for availability)
   } else if (idempotencyCheck?.is_duplicate) {
     console.log(`Duplicate webhook event ${eventId}, returning cached response`);
     return new Response(
       JSON.stringify(idempotencyCheck.cached_response || { received: true }),
       {
         status: idempotencyCheck.cached_status || 200,
         headers: { ...dynamicCorsHeaders, "Content-Type": "application/json" }
       }
     );
   }

   // Store record_id for later update
   const idempotencyRecordId = idempotencyCheck?.record_id;
   ```

2. Keep signature verification AFTER idempotency check (current position is fine)

3. Store the record_id in a variable to update later

IMPORTANT: Do NOT change any existing business logic. Only add the idempotency wrapper.
  </action>
  <verify>
Search for the idempotency check in the updated file:
```bash
grep -n "check_webhook_idempotency" maguey-pass-lounge/supabase/functions/stripe-webhook/index.ts
```
  </verify>
  <done>
- Webhook handler calls check_webhook_idempotency RPC at entry
- Duplicate events return 200 with cached response
- New events continue to processing
- Idempotency failures are logged but don't block processing
  </done>
</task>

<task type="auto">
  <name>Task 2: Update idempotency record after successful processing</name>
  <files>maguey-pass-lounge/supabase/functions/stripe-webhook/index.ts</files>
  <action>
Update the idempotency record with the response AFTER successful processing:

1. Before returning the success response (at the end of successful processing):
   ```typescript
   // Update idempotency record with response
   if (idempotencyRecordId) {
     const responseData = { received: true, eventType: event.type };
     await supabase.rpc('update_webhook_idempotency', {
       p_record_id: idempotencyRecordId,
       p_response_data: responseData,
       p_response_status: 200,
       p_metadata: {
         event_type: event.type,
         processed_at: new Date().toISOString()
       }
     }).catch(err => {
       // Log but don't fail - idempotency update is not critical path
       console.error('Failed to update idempotency record:', err);
     });
   }
   ```

2. For error responses, update with the error status:
   ```typescript
   // In error handlers, if we have an idempotency record, update it
   if (idempotencyRecordId) {
     await supabase.rpc('update_webhook_idempotency', {
       p_record_id: idempotencyRecordId,
       p_response_data: { error: errorMessage },
       p_response_status: statusCode
     }).catch(() => {}); // Silent fail
   }
   ```

3. Make idempotency updates non-blocking (no await in critical path, or use .catch())

IMPORTANT: Updates to idempotency records should NEVER fail the webhook response.
  </action>
  <verify>
Search for the update call:
```bash
grep -n "update_webhook_idempotency" maguey-pass-lounge/supabase/functions/stripe-webhook/index.ts
```
  </verify>
  <done>
- Successful webhook responses update idempotency record
- Error responses update idempotency record with error status
- Idempotency updates are non-blocking (use .catch())
  </done>
</task>

<task type="auto">
  <name>Task 3: Make email sending non-blocking</name>
  <files>maguey-pass-lounge/supabase/functions/stripe-webhook/index.ts</files>
  <action>
Convert synchronous email sending to fire-and-forget pattern:

1. Find all `await sendTicketEmail()` and `await sendVipConfirmationEmail()` calls

2. Convert from blocking:
   ```typescript
   // BEFORE (blocking)
   await sendTicketEmail(ticketData);
   ```

   To fire-and-forget:
   ```typescript
   // AFTER (non-blocking)
   sendTicketEmail(ticketData).catch(err => {
     console.error('Email sending failed, will be retried:', {
       error: err.message,
       ticketId: ticketData.ticketId,
       email: ticketData.email
     });
     // TODO: In Phase 2 (Email Reliability), add to email retry queue
   });
   ```

3. For each email send, add structured error logging:
   - Log email recipient
   - Log ticket/reservation ID
   - Log error message
   - Do NOT log sensitive data (full email content)

4. Add comment noting Phase 2 will add retry queue

REASON: Webhook must respond to Stripe within 5 seconds. Email services can be slow.
If email fails, webhook should still succeed - email retry is handled separately.
  </action>
  <verify>
Verify no await on email functions:
```bash
grep -n "await send.*Email" maguey-pass-lounge/supabase/functions/stripe-webhook/index.ts
```
Should return no results (or only in non-critical paths).
  </verify>
  <done>
- Email sending is fire-and-forget (no await blocking response)
- Email failures are logged with context for debugging
- Webhook response is not delayed by email service latency
  </done>
</task>

</tasks>

<verification>
1. Deploy webhook to local Supabase: `cd maguey-pass-lounge && npx supabase functions serve stripe-webhook`
2. Send test webhook twice with same event.id - second should return cached response
3. Check logs for "Duplicate webhook event" message on second call
4. Verify email sending doesn't block webhook response time
</verification>

<success_criteria>
- Duplicate Stripe events are detected and silently skipped (return 200)
- New events are processed normally and recorded in idempotency table
- Email sending failures don't fail the webhook
- Webhook response time is under 5 seconds even if email service is slow
</success_criteria>

<output>
After completion, create `.planning/phases/01-payment-flow-hardening/01-02-SUMMARY.md`
</output>
