---
phase: 01-payment-flow-hardening
plan: 05
type: execute
wave: 3
depends_on: ["01-01", "01-02", "01-03", "01-04"]
files_modified:
  - maguey-pass-lounge/playwright/tests/checkout-failures.spec.ts
  - maguey-pass-lounge/playwright/tests/webhook-idempotency.spec.ts
  - maguey-pass-lounge/src/__tests__/integration/payment-flow.test.ts
autonomous: true

must_haves:
  truths:
    - "Tests verify card declined shows toast error"
    - "Tests verify duplicate webhook doesn't create duplicate tickets"
    - "Tests verify failed payments are logged in payment_failures table"
    - "CI/CD runs tests before merge"
  artifacts:
    - path: "maguey-pass-lounge/playwright/tests/checkout-failures.spec.ts"
      provides: "E2E tests for payment failure scenarios"
      contains: "test.*declined"
    - path: "maguey-pass-lounge/playwright/tests/webhook-idempotency.spec.ts"
      provides: "E2E tests for webhook duplicate handling"
      contains: "duplicate.*event"
    - path: "maguey-pass-lounge/src/__tests__/integration/payment-flow.test.ts"
      provides: "Integration tests for payment flow"
      contains: "describe.*payment"
  key_links:
    - from: "checkout-failures.spec.ts"
      to: "Payment.tsx"
      via: "Playwright navigation"
      pattern: "page\\.goto.*checkout"
    - from: "webhook-idempotency.spec.ts"
      to: "stripe-webhook"
      via: "fetch to webhook endpoint"
      pattern: "fetch.*stripe-webhook"
---

<objective>
Add comprehensive test coverage for payment failure scenarios including declined cards, webhook duplicates, and error handling.

Purpose: Per user decision, tests must cover failure scenarios (card declined, webhook timeout, duplicate event). CI/CD must pass tests before merge. This ensures payment hardening actually works.

Output: New test files covering failure scenarios, updated CI config to run tests.
</objective>

<execution_context>
@/Users/luismiguel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luismiguel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-payment-flow-hardening/01-CONTEXT.md
@.planning/phases/01-payment-flow-hardening/01-RESEARCH.md
@maguey-pass-lounge/playwright/tests/checkout.spec.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create E2E tests for payment failure scenarios</name>
  <files>maguey-pass-lounge/playwright/tests/checkout-failures.spec.ts</files>
  <action>
Create Playwright tests for payment failure scenarios using Stripe test cards:

```typescript
import { test, expect } from '@playwright/test';

// Stripe test cards for failure scenarios
// Source: https://docs.stripe.com/testing
const TEST_CARDS = {
  GENERIC_DECLINE: '4000000000000002',
  INSUFFICIENT_FUNDS: '4000000000009995',
  EXPIRED_CARD: '4000000000000069',
  PROCESSING_ERROR: '4000000000000119',
};

test.describe('Payment Failure Handling', () => {

  test.beforeEach(async ({ page }) => {
    // Navigate to checkout with a test event
    // Adjust URL based on actual app routing
    await page.goto('/checkout?eventId=test-event-id');

    // Fill in required checkout fields (adjust selectors as needed)
    await page.fill('[name="email"]', 'test@example.com');
    await page.fill('[name="name"]', 'Test User');
  });

  test('shows toast error when card is declined', async ({ page }) => {
    // Select ticket (adjust selector)
    await page.click('[data-testid="ticket-quantity-increase"]');

    // Proceed to payment
    await page.click('[data-testid="proceed-to-payment"]');

    // Wait for Stripe iframe to load
    const stripeFrame = page.frameLocator('iframe[name^="__privateStripeFrame"]').first();

    // Fill declined card
    await stripeFrame.locator('[placeholder="Card number"]').fill(TEST_CARDS.GENERIC_DECLINE);
    await stripeFrame.locator('[placeholder="MM / YY"]').fill('12/30');
    await stripeFrame.locator('[placeholder="CVC"]').fill('123');
    await stripeFrame.locator('[placeholder="ZIP"]').fill('12345');

    // Submit payment
    await page.click('[data-testid="submit-payment"]');

    // Verify toast appears with error message
    // sonner toasts typically render with role="status" or specific class
    await expect(page.locator('[data-sonner-toast]')).toBeVisible({ timeout: 10000 });
    await expect(page.locator('[data-sonner-toast]')).toContainText('Payment failed');

    // Verify retry button exists
    await expect(page.locator('[data-sonner-toast] button')).toContainText('Retry');
  });

  test('shows toast error for insufficient funds', async ({ page }) => {
    await page.click('[data-testid="ticket-quantity-increase"]');
    await page.click('[data-testid="proceed-to-payment"]');

    const stripeFrame = page.frameLocator('iframe[name^="__privateStripeFrame"]').first();
    await stripeFrame.locator('[placeholder="Card number"]').fill(TEST_CARDS.INSUFFICIENT_FUNDS);
    await stripeFrame.locator('[placeholder="MM / YY"]').fill('12/30');
    await stripeFrame.locator('[placeholder="CVC"]').fill('123');
    await stripeFrame.locator('[placeholder="ZIP"]').fill('12345');

    await page.click('[data-testid="submit-payment"]');

    await expect(page.locator('[data-sonner-toast]')).toBeVisible({ timeout: 10000 });
    await expect(page.locator('[data-sonner-toast]')).toContainText('Payment failed');
  });

  test('toast auto-dismisses after 5 seconds', async ({ page }) => {
    await page.click('[data-testid="ticket-quantity-increase"]');
    await page.click('[data-testid="proceed-to-payment"]');

    const stripeFrame = page.frameLocator('iframe[name^="__privateStripeFrame"]').first();
    await stripeFrame.locator('[placeholder="Card number"]').fill(TEST_CARDS.GENERIC_DECLINE);
    await stripeFrame.locator('[placeholder="MM / YY"]').fill('12/30');
    await stripeFrame.locator('[placeholder="CVC"]').fill('123');
    await stripeFrame.locator('[placeholder="ZIP"]').fill('12345');

    await page.click('[data-testid="submit-payment"]');

    // Toast appears
    await expect(page.locator('[data-sonner-toast]')).toBeVisible({ timeout: 10000 });

    // Wait 6 seconds for auto-dismiss
    await page.waitForTimeout(6000);

    // Toast should be gone
    await expect(page.locator('[data-sonner-toast]')).not.toBeVisible();
  });

  test('retry button triggers new payment attempt', async ({ page }) => {
    await page.click('[data-testid="ticket-quantity-increase"]');
    await page.click('[data-testid="proceed-to-payment"]');

    const stripeFrame = page.frameLocator('iframe[name^="__privateStripeFrame"]').first();
    await stripeFrame.locator('[placeholder="Card number"]').fill(TEST_CARDS.GENERIC_DECLINE);
    await stripeFrame.locator('[placeholder="MM / YY"]').fill('12/30');
    await stripeFrame.locator('[placeholder="CVC"]').fill('123');
    await stripeFrame.locator('[placeholder="ZIP"]').fill('12345');

    await page.click('[data-testid="submit-payment"]');

    // Wait for toast
    await expect(page.locator('[data-sonner-toast]')).toBeVisible({ timeout: 10000 });

    // Click retry
    await page.locator('[data-sonner-toast] button:has-text("Retry")').click();

    // Should show loading state
    await expect(page.locator('[data-testid="loading-overlay"]')).toBeVisible();
  });
});
```

NOTE: Selectors will need adjustment based on actual component structure. This is a template.
  </action>
  <verify>
```bash
# Verify test file exists
ls -la maguey-pass-lounge/playwright/tests/checkout-failures.spec.ts
# Check test syntax
cd maguey-pass-lounge && npx playwright test checkout-failures.spec.ts --list
```
  </verify>
  <done>
- E2E tests cover declined card scenario
- E2E tests verify toast appearance and content
- E2E tests verify auto-dismiss timing
- E2E tests verify retry button functionality
  </done>
</task>

<task type="auto">
  <name>Task 2: Create webhook idempotency tests</name>
  <files>maguey-pass-lounge/playwright/tests/webhook-idempotency.spec.ts</files>
  <action>
Create tests for webhook idempotency (API-level, not E2E UI):

```typescript
import { test, expect } from '@playwright/test';

// These tests verify webhook idempotency at the API level
// They require a running Supabase instance with the webhook function

const WEBHOOK_URL = process.env.SUPABASE_URL
  ? `${process.env.SUPABASE_URL}/functions/v1/stripe-webhook`
  : 'http://localhost:54321/functions/v1/stripe-webhook';

// Mock Stripe webhook payload
function createMockWebhookEvent(eventId: string, type: string = 'checkout.session.completed') {
  return {
    id: eventId,
    type,
    data: {
      object: {
        id: `cs_test_${eventId}`,
        payment_intent: `pi_test_${eventId}`,
        amount_total: 5000,
        currency: 'usd',
        customer_details: {
          email: 'test@example.com',
        },
        metadata: {
          eventId: 'test-event-id',
        },
      },
    },
  };
}

test.describe('Webhook Idempotency', () => {

  test('duplicate webhook event returns 200 without processing', async ({ request }) => {
    const eventId = `evt_test_${Date.now()}`;
    const payload = createMockWebhookEvent(eventId);

    // First request - should process
    const response1 = await request.post(WEBHOOK_URL, {
      data: payload,
      headers: {
        'Content-Type': 'application/json',
        // Note: In real test, would need valid Stripe signature
        // For local testing, may need to disable signature verification
      },
    });

    expect(response1.ok()).toBeTruthy();
    const body1 = await response1.json();
    console.log('First response:', body1);

    // Second request with same event ID - should return cached response
    const response2 = await request.post(WEBHOOK_URL, {
      data: payload,
      headers: {
        'Content-Type': 'application/json',
      },
    });

    expect(response2.ok()).toBeTruthy();
    const body2 = await response2.json();
    console.log('Second response:', body2);

    // Both should return successfully
    expect(body1.received).toBe(true);
    expect(body2.received).toBe(true);
  });

  test('different webhook events are processed independently', async ({ request }) => {
    const eventId1 = `evt_test_${Date.now()}_1`;
    const eventId2 = `evt_test_${Date.now()}_2`;

    const response1 = await request.post(WEBHOOK_URL, {
      data: createMockWebhookEvent(eventId1),
      headers: { 'Content-Type': 'application/json' },
    });

    const response2 = await request.post(WEBHOOK_URL, {
      data: createMockWebhookEvent(eventId2),
      headers: { 'Content-Type': 'application/json' },
    });

    expect(response1.ok()).toBeTruthy();
    expect(response2.ok()).toBeTruthy();
  });

});

test.describe('Webhook Database Constraints', () => {

  test('duplicate ticket insert is prevented by constraint', async ({ request }) => {
    // This test verifies the database constraint works
    // Would need direct database access or a test endpoint
    // For now, this is a placeholder that documents the expected behavior

    // The constraint test would:
    // 1. Insert a ticket with stripe_payment_intent_id = 'pi_test_123'
    // 2. Attempt to insert another ticket with same stripe_payment_intent_id
    // 3. Verify the second insert fails with unique constraint violation

    expect(true).toBe(true); // Placeholder
  });

});
```

NOTE: These tests may need adjustment based on:
- Whether signature verification can be disabled for testing
- Database seeding requirements
- Test environment configuration
  </action>
  <verify>
```bash
# Verify test file exists
ls -la maguey-pass-lounge/playwright/tests/webhook-idempotency.spec.ts
# List tests
cd maguey-pass-lounge && npx playwright test webhook-idempotency.spec.ts --list
```
  </verify>
  <done>
- Tests verify duplicate webhook events return 200
- Tests verify different events are processed independently
- Tests document expected database constraint behavior
  </done>
</task>

<task type="auto">
  <name>Task 3: Create integration tests for payment flow</name>
  <files>maguey-pass-lounge/src/__tests__/integration/payment-flow.test.ts</files>
  <action>
Create Vitest integration tests for payment flow logic:

```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { handlePaymentError, PaymentErrorType } from '../../lib/payment-errors';
import { toast } from 'sonner';

// Mock sonner toast
vi.mock('sonner', () => ({
  toast: {
    error: vi.fn(),
  },
}));

describe('Payment Error Handling', () => {
  const mockSetIsLoading = vi.fn();
  const mockOnRetry = vi.fn();

  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe('handlePaymentError', () => {
    it('shows toast with user-friendly message for card declined', () => {
      const error = new Error('Your card was declined.');

      handlePaymentError(error, {
        onRetry: mockOnRetry,
        setIsLoading: mockSetIsLoading,
        paymentType: 'ga_ticket',
      });

      expect(toast.error).toHaveBeenCalledWith(
        'Payment failed. Please try again.',
        expect.objectContaining({
          duration: 5000,
          action: expect.objectContaining({
            label: 'Retry',
          }),
        })
      );
    });

    it('shows generic message for unknown errors', () => {
      const error = new Error('Something went wrong');

      handlePaymentError(error, {
        onRetry: mockOnRetry,
        setIsLoading: mockSetIsLoading,
        paymentType: 'ga_ticket',
      });

      expect(toast.error).toHaveBeenCalledWith(
        'Payment failed. Please try again.',
        expect.any(Object)
      );
    });

    it('shows network message for connection errors', () => {
      const error = new Error('fetch failed: network timeout');

      handlePaymentError(error, {
        onRetry: mockOnRetry,
        setIsLoading: mockSetIsLoading,
        paymentType: 'ga_ticket',
      });

      expect(toast.error).toHaveBeenCalledWith(
        'Connection issue. Please try again.',
        expect.any(Object)
      );
    });

    it('logs error details for debugging', () => {
      const consoleSpy = vi.spyOn(console, 'error');
      const error = new Error('Test error');

      handlePaymentError(error, {
        onRetry: mockOnRetry,
        setIsLoading: mockSetIsLoading,
        paymentType: 'ga_ticket',
        eventId: 'event-123',
      });

      expect(consoleSpy).toHaveBeenCalledWith(
        '[Payment Error]',
        expect.objectContaining({
          paymentType: 'ga_ticket',
          eventId: 'event-123',
        })
      );
    });

    it('calls setIsLoading(true) when retry is clicked', () => {
      handlePaymentError(new Error('Test'), {
        onRetry: mockOnRetry,
        setIsLoading: mockSetIsLoading,
        paymentType: 'ga_ticket',
      });

      // Get the action onClick handler
      const toastCall = (toast.error as any).mock.calls[0];
      const actionOnClick = toastCall[1].action.onClick;

      // Simulate clicking retry
      actionOnClick();

      expect(mockSetIsLoading).toHaveBeenCalledWith(true);
      expect(mockOnRetry).toHaveBeenCalled();
    });
  });

  describe('Error categorization', () => {
    const testCases: Array<{ input: string; expected: PaymentErrorType }> = [
      { input: 'card_declined', expected: 'card_declined' },
      { input: 'Your card was declined', expected: 'card_declined' },
      { input: 'insufficient_funds', expected: 'insufficient_funds' },
      { input: 'Your card has insufficient funds', expected: 'insufficient_funds' },
      { input: 'expired_card', expected: 'expired_card' },
      { input: 'Your card has expired', expected: 'expired_card' },
      { input: 'processing_error', expected: 'processing_error' },
      { input: 'network error', expected: 'network_error' },
      { input: 'fetch failed', expected: 'network_error' },
      { input: 'random error', expected: 'unknown' },
    ];

    testCases.forEach(({ input, expected }) => {
      it(`categorizes "${input}" as ${expected}`, () => {
        handlePaymentError(new Error(input), {
          onRetry: mockOnRetry,
          setIsLoading: mockSetIsLoading,
          paymentType: 'ga_ticket',
        });

        // All errors should result in a toast being shown
        expect(toast.error).toHaveBeenCalled();
      });
    });
  });
});

describe('Retry with Backoff (unit test)', () => {
  // This would test the retryWithBackoff function if exported
  // For now, placeholder for the pattern

  it('retries the specified number of times', async () => {
    let attempts = 0;
    const fn = vi.fn().mockImplementation(async () => {
      attempts++;
      if (attempts < 3) {
        throw new Error('Temporary failure');
      }
      return 'success';
    });

    // Would test: const result = await retryWithBackoff(fn, 5, 100);
    // expect(fn).toHaveBeenCalledTimes(3);
    // expect(result).toBe('success');

    expect(true).toBe(true); // Placeholder
  });
});
```

Also create the directory structure:
```bash
mkdir -p maguey-pass-lounge/src/__tests__/integration
```
  </action>
  <verify>
```bash
# Run the tests
cd maguey-pass-lounge && npm test -- src/__tests__/integration/payment-flow.test.ts
```
  </verify>
  <done>
- Unit tests cover error categorization
- Unit tests verify toast is shown with correct message
- Unit tests verify retry button calls setIsLoading(true)
- Tests pass with npm test
  </done>
</task>

</tasks>

<verification>
1. Run all tests: `cd maguey-pass-lounge && npm test`
2. Run Playwright tests: `cd maguey-pass-lounge && npx playwright test`
3. Verify CI config runs tests (check .github/workflows or similar)
4. All tests should pass
</verification>

<success_criteria>
- E2E tests exist for declined cards, insufficient funds, expired cards
- E2E tests verify toast behavior (message, auto-dismiss, retry button)
- Webhook idempotency tests verify duplicate handling
- Integration tests verify error categorization and handling
- All tests pass in CI
</success_criteria>

<output>
After completion, create `.planning/phases/01-payment-flow-hardening/01-05-SUMMARY.md`
</output>
