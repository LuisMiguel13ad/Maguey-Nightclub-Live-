---
phase: 19-dashboard-accuracy
plan: 03
type: execute
wave: 2
depends_on: ["19-01"]
files_modified:
  - maguey-gate-scanner/src/pages/OwnerDashboard.tsx
  - maguey-gate-scanner/src/hooks/useDashboardRealtime.ts
autonomous: true

must_haves:
  truths:
    - "New order insertion triggers only the orders and revenue section refresh, not full dashboard reload"
    - "New scan_logs insertion triggers only revenue stats refresh, not full dashboard reload"
    - "Email queue changes still trigger only email status refresh (preserved)"
    - "Scanner heartbeat changes still trigger only scanner status refresh (preserved)"
    - "Dashboard shows live indicator from useDashboardRealtime hook"
  artifacts:
    - path: "maguey-gate-scanner/src/pages/OwnerDashboard.tsx"
      provides: "Targeted refresh functions and subscription map"
      contains: "fetchRecentOrders"
    - path: "maguey-gate-scanner/src/hooks/useDashboardRealtime.ts"
      provides: "Enhanced hook with table-to-callback mapping"
      contains: "onTableUpdate"
  key_links:
    - from: "maguey-gate-scanner/src/pages/OwnerDashboard.tsx"
      to: "maguey-gate-scanner/src/hooks/useDashboardRealtime.ts"
      via: "import and use useDashboardRealtime with per-table callbacks"
      pattern: "useDashboardRealtime"
    - from: "maguey-gate-scanner/src/hooks/useDashboardRealtime.ts"
      to: "supabase realtime channel"
      via: "postgres_changes subscription with table dispatch"
      pattern: "postgres_changes.*table"
---

<objective>
Replace the full-dashboard-reload-on-every-change pattern with targeted section refreshes, and integrate the existing but unused useDashboardRealtime hook.

Purpose: Currently, any change to scan_logs, tickets, or orders triggers a complete `loadData()` call (3+ database queries totaling 300-600ms). During peak scanning (1 scan/second), this causes 1 full reload/second. Email and scanner status already use targeted refresh — this plan extends the pattern to all dashboard sections, reducing database load by 60-80%.

Output: OwnerDashboard.tsx with split fetch functions and useDashboardRealtime integration. useDashboardRealtime.ts enhanced with per-table callback support.
</objective>

<execution_context>
@/Users/luismiguel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luismiguel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/19-dashboard-accuracy/19-CONTEXT.md
@.planning/phases/19-dashboard-accuracy/19-RESEARCH.md
@.planning/phases/19-dashboard-accuracy/19-01-SUMMARY.md

Key source files:
@maguey-gate-scanner/src/pages/OwnerDashboard.tsx — lines 281-553 (loadData), lines 555-633 (real-time subscriptions)
@maguey-gate-scanner/src/hooks/useDashboardRealtime.ts — currently unused hook with visibility-aware reconnection

Existing targeted refresh examples:
- fetchEmailStatuses (lines 228-242) — refreshes only email section
- fetchScannerStatuses (lines 244-251) — refreshes only scanner section
- Both wired to specific tables at lines 603-622
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance useDashboardRealtime hook with per-table callbacks</name>
  <files>maguey-gate-scanner/src/hooks/useDashboardRealtime.ts</files>
  <action>
Update the useDashboardRealtime hook to support a per-table callback map instead of a single onUpdate callback. This allows the dashboard to dispatch different refresh functions based on which table changed.

1. Update the options interface to support table-specific callbacks:

```typescript
type TableName = 'tickets' | 'orders' | 'vip_reservations' | 'scan_logs' | 'email_queue' | 'scanner_heartbeats' | 'events';

interface UseDashboardRealtimeOptions {
  eventId?: string;
  tables?: TableName[];
  onUpdate?: () => void;                              // Keep existing: fires on any change
  onTableUpdate?: Partial<Record<TableName, () => void>>;  // NEW: per-table callbacks
}
```

2. Update the `setupSubscription` function. In the `.on('postgres_changes', ...)` callback (around line 68), dispatch to the table-specific callback if available, otherwise fall to the generic onUpdate:

```typescript
tables.forEach((table) => {
  channel = channel.on(
    'postgres_changes',
    {
      event: '*',
      schema: 'public',
      table,
    },
    () => {
      setLastUpdate(new Date());
      // Dispatch to table-specific callback if available
      const tableCallback = onTableUpdateRef.current?.[table];
      if (tableCallback) {
        tableCallback();
      } else {
        // Fallback to generic onUpdate
        onUpdateRef.current?.();
      }
    }
  );
});
```

3. Add a ref for onTableUpdate (same pattern as onUpdateRef at line 36):

```typescript
const onTableUpdateRef = useRef(onTableUpdate);
useEffect(() => {
  onTableUpdateRef.current = onTableUpdate;
}, [onTableUpdate]);
```

4. On visibility change (tab regain focus at line 92-96), call ALL table callbacks plus onUpdate to catch up on missed changes:

```typescript
if (document.visibilityState === 'visible') {
  setupSubscription();
  setLastUpdate(new Date());
  // Refresh all sections on tab focus
  if (onTableUpdateRef.current) {
    Object.values(onTableUpdateRef.current).forEach(cb => cb?.());
  }
  onUpdateRef.current?.();
}
```

Keep the existing return type (`isLive`, `lastUpdate`, `reconnect`) unchanged — backward compatible.
  </action>
  <verify>
Run `npm run build --workspace=maguey-gate-scanner` — no type errors.
Verify the hook still exports `useDashboardRealtime` with compatible return type.
Grep for `onTableUpdate` in useDashboardRealtime.ts — should find the new option.
  </verify>
  <done>
useDashboardRealtime hook supports per-table callbacks via `onTableUpdate` option. Backward compatible — existing `onUpdate` still works. Build succeeds.
  </done>
</task>

<task type="auto">
  <name>Task 2: Split loadData into targeted fetch functions and wire subscriptions</name>
  <files>maguey-gate-scanner/src/pages/OwnerDashboard.tsx</files>
  <action>
**Part A — Extract targeted fetch functions from loadData:**

The current `loadData()` function (lines 281-553) does everything. Split the logic into focused functions that can be called independently. Keep `loadData()` as the initial load that calls all of them, but make each independently callable:

1. **fetchRevenueAndStats** — Extract the tickets query and all revenue/stats calculations (lines 299-502). This includes:
   - Tickets query (lines 300-312)
   - Type distribution calculation (lines 320-336)
   - Revenue calculations (lines 377-502)
   - Setting stats, dailyPerformance, trendDelta, weekOverWeek, ticketTypeDistribution

2. **fetchRecentOrders** — Extract the orders query and transform (lines 314-518). This includes:
   - Orders query with tickets join (as modified by plan 19-01)
   - Peak buying times calculation (lines 338-352)
   - Order transform and insights
   - Setting recentOrders, peakBuyingTimes, insights

3. **fetchUpcomingEvents** — Extract the events query (lines 354-503 the events portion). This includes:
   - Events query (lines 354-360)
   - Ticket types capacity query (lines 362-369)
   - Upcoming event summaries (lines 451-477)
   - Setting upcomingEvents

Keep the existing `fetchEmailStatuses` and `fetchScannerStatuses` unchanged — they're already correct.

Restructure `loadData()` to call all fetchers:
```typescript
const loadData = async () => {
  setIsLoading(true);
  if (!isSupabaseConfigured()) {
    setIsLoading(false);
    return;
  }
  try {
    // Fire all fetchers in parallel
    await Promise.all([
      fetchRevenueAndStats(),
      fetchRecentOrders(),
      fetchUpcomingEvents(),
    ]);
    // Non-blocking: email and scanner
    fetchEmailStatuses();
    fetchScannerStatuses();
  } catch (error: any) {
    console.error("Error loading dashboard data:", error);
    toast({
      variant: "destructive",
      title: "Error loading data",
      description: error.message,
    });
  } finally {
    setIsLoading(false);
  }
};
```

IMPORTANT: Each fetch function should be wrapped in its own try/catch so one failure doesn't block others. Move `setIsLoading(false)` to the finally block of loadData only.

**Part B — Replace manual subscription with useDashboardRealtime:**

1. Add import at top of file:
```typescript
import { useDashboardRealtime } from '@/hooks/useDashboardRealtime';
```

2. Remove the entire manual useEffect real-time subscription block (lines 555-633) — the one that creates `supabase.channel('dashboard-updates')`.

3. Remove the `realtimeChannelRef` state declaration (line 154) and all references to it.

4. Remove the import of `RealtimeChannel` from `@supabase/supabase-js` (line 6) if no longer used.

5. Add the useDashboardRealtime hook call inside the component (after the fetch functions are defined):

```typescript
const { isLive, lastUpdate } = useDashboardRealtime({
  tables: ['tickets', 'orders', 'scan_logs', 'email_queue', 'scanner_heartbeats', 'events'],
  onTableUpdate: {
    tickets: () => fetchRevenueAndStats(),
    orders: () => {
      fetchRevenueAndStats();
      fetchRecentOrders();
    },
    scan_logs: () => fetchRevenueAndStats(),
    events: () => fetchUpcomingEvents(),
    email_queue: () => fetchEmailStatuses(),
    scanner_heartbeats: () => fetchScannerStatuses(),
  },
});
```

This maps each table change to only the relevant refresh functions:
- `tickets` change → refresh revenue stats only (not orders, not events)
- `orders` change → refresh revenue (totals change) + recent orders
- `scan_logs` change → refresh revenue (scanned count) only
- `events` change → refresh upcoming events only
- `email_queue` change → refresh email statuses only (same as before)
- `scanner_heartbeats` change → refresh scanner statuses only (same as before)

6. Optionally, display the live indicator using `isLive` somewhere on the dashboard (e.g., near the refresh button). This is optional — if there's a natural place to show a green dot or "Live" badge, add it. If not, skip. The key benefit is the subscription management and auto-reconnection on tab focus.

NOTE: The fetch functions (fetchRevenueAndStats, fetchRecentOrders, fetchUpcomingEvents) must be defined using `useCallback` or as stable references since they'll be called from the hook. Since OwnerDashboard.tsx uses `@ts-nocheck`, this won't cause type errors, but define them before the hook call. Alternatively, since the hook stores callbacks via refs (onTableUpdateRef), the functions don't need to be memoized — the ref pattern handles staleness.
  </action>
  <verify>
Run `npm run build --workspace=maguey-gate-scanner` — no build errors.
Grep for `loadData()` in the real-time subscription section — should NOT appear (replaced with targeted calls).
Grep for `useDashboardRealtime` in OwnerDashboard.tsx — should find the hook import and usage.
Grep for `dashboard-updates` channel name in OwnerDashboard.tsx — should NOT appear (manual subscription removed).
Grep for `fetchRevenueAndStats` in OwnerDashboard.tsx — should find the new function.
Grep for `fetchRecentOrders` in OwnerDashboard.tsx — should find the new function.
  </verify>
  <done>
loadData() split into fetchRevenueAndStats, fetchRecentOrders, fetchUpcomingEvents. Manual real-time subscription replaced with useDashboardRealtime hook using per-table dispatch. Each table change triggers only relevant fetch functions. Build succeeds. Database queries per real-time event reduced from 3+ to 1.
  </done>
</task>

</tasks>

<verification>
1. `npm run build --workspace=maguey-gate-scanner` succeeds
2. No `loadData()` calls in real-time subscription handlers
3. useDashboardRealtime hook used with per-table callbacks
4. Manual `supabase.channel('dashboard-updates')` subscription removed
5. Email and scanner status still refresh independently (preserved behavior)
6. loadData() still works for initial page load (calls all fetchers)
</verification>

<success_criteria>
- Table-specific changes trigger only relevant section refreshes (not full dashboard reload)
- useDashboardRealtime hook integrated with per-table callback dispatch
- Initial page load still works correctly (all data loads)
- Email and scanner targeted refresh patterns preserved
- Build passes without errors
- GSD item 14 addressed (R17)
</success_criteria>

<output>
After completion, create `.planning/phases/19-dashboard-accuracy/19-03-SUMMARY.md`
</output>
